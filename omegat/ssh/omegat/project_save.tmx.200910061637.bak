<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="1.8.1_2"
    segtype="paragraph"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>The Secure Shell (SSH) Connection Protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュア シェル (SSH) コネクションプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Status of This Memo</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメモについて</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Distribution of this memo is unlimited.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメモの配布は制限しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright (C) The Internet Society (2006).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Copyright (C) The Internet Society (2006). 訳者: 春山 征吾 &lt;haruyama@unixuser.org&gt; </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract</seg>
      </tuv>
      <tuv lang="JA">
        <seg>概要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes the SSH Connection Protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, SSH コネクションプロトコルについて記述する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Table of Contents</seg>
      </tuv>
      <tuv lang="JA">
        <seg>目次</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イントロダクション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'service name' for this protocol is &quot;ssh-connection&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルの 'service name' は, &quot;ssh-connection&quot; だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global Requests</seg>
      </tuv>
      <tuv lang="JA">
        <seg>全体的な要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>request-specific data follows</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要求特有のデータが続く.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually, the 'response specific data' is non-existent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常, 'response specific data' は存在しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Channel Mechanism</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルのメカニズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All terminal sessions, forwarded connections, etc., are channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのターミナルのセッション, 転送された接続などは, チャンネルだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either side may open a channel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの側からもチャンネルを開ける.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Channels are identified by numbers at each end.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルは両方の側で番号によって識別される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Channels are flow-controlled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルはフロー制御される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opening a Channel</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルの開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>channel type specific data follows</seg>
      </tuv>
      <tuv lang="JA">
        <seg>channel type が後に続くデータを指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IANA will not assign Channel Connection</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANAは, 0xFE000000 から 0xFFFFFFFF の範囲の チャンネル接続失敗の'reason code' の値は割り当てない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Essentially, it is for experimentation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基本的に, この範囲は実験のためにある. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Transfer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データ転送</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data transfer is done with messages of the following type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データの転送は次の種類のメッセージで行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, some channels can transfer several types of data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて, いくつかのデータの種類を転送するチャンネルがある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, only the following type is defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在, 次の種類だけが定義されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closing a Channel</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルの終了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No explicit response is sent to this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージに明示的な返答は送られない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Channel-Specific Requests</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネル特有の要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All channel-specific requests use the following format.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべてのチャンネル特有の要求は次の形式を用いる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>type-specific data follows</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タイプに特有のデータが続く.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If 'want reply' is FALSE, no response will be sent to the request.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'want reply' が FALSE なら, 要求に対する返答は送られない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interactive Sessions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インタラクティブなセッション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A session is a remote execution of a program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッションは, プログラムのリモートな実行だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple sessions can be active simultaneously.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のセッションが同時に有効になりうる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opening a Session</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッションの開始</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A session is started by sending the following message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッションは, 次のメッセージを送ることで開始される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requesting a Pseudo-Terminal</seg>
      </tuv>
      <tuv lang="JA">
        <seg>擬似ターミナルの要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'encoded terminal modes' are described in Section 8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'encoded terminal modes' は 8節で記述する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dimension parameters are only informational.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次元パラメータは, 単に情報を提供するだけだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client SHOULD ignore pty requests.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クリアントは, pty 要求を無視する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X11 Forwarding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11 の転送</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requesting X11 Forwarding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11 転送の要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'x11 authentication cookie' MUST be hexadecimal encoded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'x11 authentication cookie' は 16進にエンコードされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The X Protocol is documented in [SCHEIFLER].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X のプロトコルは, [SCHEIFLER] に記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X11 Channels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11 のチャンネル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X11 channels are opened with a channel open request.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11 のチャンネルは, チャンネル開始要求で開始される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Environment Variable Passing</seg>
      </tuv>
      <tuv lang="JA">
        <seg>環境変数の転送</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Starting a Shell or a Command</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シェルないしコマンドの起動</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'command' string may contain a path.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'command' 文字列はパスを含んでもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This last form executes a predefined subsystem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この最後の形式は, 先に定義されたサブシステムを実行する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client SHOULD ignore these messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントはこれらのメッセージを無視する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Session Data Transfer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッションのデータ転送</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Window Dimension Change Message</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ウィンドウ容量変更メッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A response SHOULD NOT be sent to this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージに対しては返答を送らないほうがよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local Flow Control</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルなフロー制御</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client MAY ignore this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, このメッセージを無視してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No response is sent to this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージには応答は送られない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signals</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグナル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returning Exit Status</seg>
      </tuv>
      <tuv lang="JA">
        <seg>終了ステータスの返却</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returning the status is RECOMMENDED.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ステータスを返すことは推奨されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client MAY ignore these messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントこれらのメッセージを無視してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remote command may also terminate violently due to a signal.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リモートのコマンドは, シグナルによって強制的に終了されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such a condition can be indicated by the following message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのような状態は, 次のメッセージによって示される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'signal name' is one of the following (these are from [POSIX]).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'signal name' は次のうちの1つだ (これらは [POSIX] による).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1     VINTR       Interrupt character; 255 if none.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1     VINTR       割り込み文字. もしなければ255.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3     VERASE      Erase the character to left of the cursor.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>3     VERASE      カーソルの左側の文字を消す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4     VKILL       Kill the current input line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>4     VKILL       現在の入力行を消す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7     VEOL2       Additional end-of-line character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>7     VEOL2       追加の end-of-line 文字.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9     VSTOP       Pauses output (normally control-S).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>9     VSTOP       出力を中断する. (通常は control-S).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10    VSUSP       Suspends the current program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>10    VSUSP       現在のプログラムを中断する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>11    VDSUSP      Another suspend character.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>11    VDSUSP      別の中断文字.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12    VREPRINT    Reprints the current input line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>12    VREPRINT    現在の入力行を再表示する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>13    VWERASE     Erases a word left of cursor.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>13    VWERASE     カーソルの左の word を消す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>16    VSWTCH      Switch to a different shell layer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>16    VSWTCH      別の shell layer に切り替える.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>18    VDISCARD    Toggles the flushing of terminal output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>18    VDISCARD    端末の出力をflushするかを切り替える.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>30    IGNPAR      The ignore parity flag.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>30    IGNPAR      パリティ無視フラグ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>31    PARMRK      Mark parity and framing errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>31    PARMRK      パリティーとフレームのエラーをマークを追加する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>32    INPCK       Enable checking of parity errors.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>32    INPCK       パリティエラーのチェックを有効にする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>33    ISTRIP      Strip 8th bit off characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>33    ISTRIP      文字の8bit目を落す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>34    INLCR       Map NL into CR on input.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>34    INLCR       入力でNLをCRに置き換える.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>35    IGNCR       Ignore CR on input.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>35    IGNCR       入力でCRを無視する. (</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>36    ICRNL       Map CR to NL on input.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>36    ICRNL       入力でCRをNLに置き換える.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>38    IXON        Enable output flow control.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>38    IXON        出力のフロー制御を有効にする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>39    IXANY       Any char will restart after stop.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>39    IXANY       どの文字でもストップ後の再開を行なう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>40    IXOFF       Enable input flow control.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>40    IXOFF       入力のフロー制御を有効にする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>41    IMAXBEL     Ring bell on input queue full.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>41    IMAXBEL     入力キューがいっぱいのときにベルを鳴らす.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>50    ISIG        Enable signals INTR, QUIT, [D]SUSP.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>50    ISIG        INTR, QUIT, [D]SUSP シグナルを有効にする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>51    ICANON      Canonicalize input lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>51    ICANON      入力行を正規化する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>53    ECHO        Enable echoing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>53    ECHO        エコーヲを有効にする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>54    ECHOE       Visually erase chars.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>54    ECHOE       視覚的なerase文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>55    ECHOK       Kill character discards current line.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>55    ECHOK       現在の行を捨てる Kill 文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>56    ECHONL      Echo NL even if ECHO is off.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>56    ECHONL      ECHO が無効でも NL をエコーする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>57    NOFLSH      Don't flush after interrupt.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>57    NOFLSH      割り込みの後でflushしない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>58    TOSTOP      Stop background jobs from output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>58    TOSTOP      バックグラウンドのジョブから出力があったらジョブを止める.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>59    IEXTEN      Enable extensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>59    IEXTEN      拡張を有効にする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>60    ECHOCTL     Echo control characters as ^(Char).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>60    ECHOCTL     ＾文字付きでコントロール文字をエコーする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>61    ECHOKE      Visual erase for line kill.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>61    ECHOKE      行の削除を視覚的に行なう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>62    PENDIN      Retype pending input.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>62    PENDIN      中断した入力を再入力する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>70    OPOST       Enable output processing.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>70    OPOST       出力処理を有効にする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>71    OLCUC       Convert lowercase to uppercase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>71    OLCUC       小文字を大文字に変換する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>72    ONLCR       Map NL to CR-NL.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>72    ONLCR       NLをCR-NLに置き換える.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>90    CS7         7 bit mode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>90    CS7         7 bit モード.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>91    CS8         8 bit mode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>91    CS8         8 bit モード.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>92    PARENB      Parity enable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>92    PARENB      パリティ有効</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>93    PARODD      Odd parity, else even.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>93    PARODD      設定されると奇数パリティ. もしくは 偶数パリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary of Message Numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージ番号のまとめ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IANA Considerations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANA の考慮</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is part of a set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, (訳注: プロトコルを定義する文書の)集合の一部分だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security Considerations</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュリティの考察</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Secure Shell (SSH) Authentication Protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュア シェル (SSH) 認証プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'service name' for this protocol is &quot;ssh-userauth&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルの 'service name' は, &quot;ssh-userauth&quot; だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Authentication Protocol Framework</seg>
      </tuv>
      <tuv lang="JA">
        <seg> 認証プロトコルのフレームワーク</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it MAY be sent by the client.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, これはクライアント側から送られてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The RECOMMENDED timeout period is 10 minutes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>タイムアウト期間の推奨は, 10分だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Requests</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証の要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All authentication requests MUST use the following message format.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての認証の要求は, 次のメッセージの形式を利用しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it is unable to</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following 'method name' values are defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の 'method name' の値が定義されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to Authentication Requests</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証の要求に対する返答</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH_MSG_USERAUTH_SUCCESS MUST be sent only once.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_USERAUTH_SUCCESS は1回のみ送られなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;none&quot; Authentication Request</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;none&quot; 認証要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This 'method name' MUST NOT be listed as supported by the server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバから送信する 'method_name' の値には, &quot;none&quot; を挙げてはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Completion of User Authentication</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザ認証の完了</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Banner Message</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バナー メッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Protocol Message Numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証プロトコルのメッセージ番号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are the general authentication message codes:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下が, 認証法に依存しない認証メッセージの番号だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public Key Authentication Method: &quot;publickey&quot;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵認証法: &quot;publickey&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any public key algorithm may be offered for use in authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どんな公開鍵アルゴリズムが認証のために提供されても構わない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The signature is sent using the following packet:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>署名は, 次のパケットを用いて送られる:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both checks succeed, this method is successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>両方のチェックが成功したら, この認証法は成功だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Password Authentication Method: &quot;password&quot;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスワード認証法: &quot;password&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Password authentication uses the following packets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスワード認証は次のパケットを利用する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Host-Based Authentication: &quot;hostbased&quot;</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホストベース認証: &quot;hostbased&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Secure Shell (SSH) Protocol Architecture</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュア シェル (SSH) プロトコル アーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9.3.5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> 9.3.5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Architecture</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アーキテクチャ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Host Keys</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホスト鍵</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each server host SHOULD have a host key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバホストは, ホスト鍵を持つ必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two different trust models can be used:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2つの異なる信頼モデルが利用できる:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>third-party coordination.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, providing the option not to check the server host key is</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それゆえ, ホスト鍵のチェックをしない選択肢は, インターネット全体のセキュリティを向上すると考えている. たとえ, この選択肢を許容する設定ではプロトコルのセキュリティが低下するとしてもだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensibility</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Policy Issues</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポリシーの問題</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security Properties</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュリティの特性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Localization and Character Set Support</seg>
      </tuv>
      <tuv lang="JA">
        <seg>地域化と文字セットのサポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When applicable, the character set for</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可能な場合は, データの文字セットは明示的に指定されなけばならない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the data MUST be explicitly specified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One big issue is the character set of the interactive session.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>インタラクティブなセッションでの文字セットは大きな問題だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Straight bit-wise, binary comparison is RECOMMENDED.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ストレートなビット単位のバイナリの比較が推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Type Representations Used in the SSH Protocols</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH プロトコルで利用されるデータ型の表現</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A byte represents an arbitrary 8-bit value (octet).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>byte は任意の8-bitの値(octet)を表す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A boolean value is stored as a single byte.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>boolean の値は, 単一のbyteに格納される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represents a 32-bit unsigned integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>32-bitの符号無し整数を表す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represents a 64-bit unsigned integer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>64-bitの 符号無し整数を表す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arbitrary length binary string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>任意の長さのバイナリ文字列</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings are also used to store text.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>stringはテキストを格納するのにも利用される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A string containing a comma-separated list of names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>カンマで区切られた name のリストを含む string</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Algorithm and Method Naming</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズムと方式の命名規則</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names MUST be case-sensitive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前は,大文字と小文字を区別しなければならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two formats for algorithm and method names:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズムと方式の名前には2つの形式がある:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They MUST have only a single at-sign in them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1つのアットマークだけが含まれなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージ番号</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH packets have message numbers in the range 1 to 255.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHのパケットは, 1 から 255 の範囲のメッセージ番号を持つ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transport layer protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トランスポート層プロトコル:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User authentication protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザ認証プロトコル:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection protocol:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクション プロトコル:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reserved for client protocols:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントプロトコルのための予約:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>128 to 191 Reserved</seg>
      </tuv>
      <tuv lang="JA">
        <seg>128 to 191 予約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local extensions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルな拡張:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>192 to 255 Local extensions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>192 to 255 ローカルな拡張</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Key Exchange Method Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  鍵交換法の名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names are case-sensitive, and MUST NOT be longer than 64 characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前は大文字小文字が区別され, 64文字以下でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each category of names listed above has a separate namespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上で挙げられたどの名前のカテゴリも, 別々の名前空間を持つ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pseudo-Random Number Generation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>擬似乱数の生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control Character Filtering</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御文字のフィルタリング</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transport</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トランスポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Confidentiality</seg>
      </tuv>
      <tuv lang="JA">
        <seg>機密性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, consider the following case:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として 次の場合を考える:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[500 ms passes, no ACK]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>[500 ms 経過し, ACKが返ってこない]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Integrity</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データの完全性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol does allow the Data Integrity mechanism to be disabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, データの完全性のメカニズムを無効にすることを許している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replay</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リプレイ(再送)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>replay of data from prior sessions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Man-in-the-middle</seg>
      </tuv>
      <tuv lang="JA">
        <seg>中間者</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section describes this and encourages administrators</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この節では, この点を詳述し, セッションを始める前にこの関係を検証することの重要性を管理者とユーザが理解するように勧めている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three cases of man-in-the-middle attacks to consider.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>考慮すべき中間者攻撃のケースは, 3つある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Denial of Service</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サービス妨害</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol is designed to be used over a reliable transport.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, 信頼できるトランスポート上で使われるように設計されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connection SHOULD be re-established if this occurs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この時, 接続は再度構築する必要がある..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers SHOULD provide features that make this</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者はこの攻撃をより難しくする特徴を提供する必要がある. 例としては, 正当なユーザがいるとわかっているクライアントの部分集合からの接続のみを許可するというものがある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Covert Channels</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コバートチャンネル(隠れチャンネル, プロトコルの想定外の手段で情報を伝えること) </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol was not designed to eliminate covert channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは, コバートチャンネルを除去するようには設計されてない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forward Secrecy</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前方秘密性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordering of Key Exchange Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換法の注文</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most-preferred method is the first in the list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もっとも優先する方法がリストの先頭だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traffic Analysis</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トラフィック解析</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak Transport</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いトランスポート</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Messages</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デバッグメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special care should be taken when designing debug messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デバッグメッセージの設計には特別な注意が必要だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local Security Policy</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルなセキュリティポリシー</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>9.4.4  Public Key Authentication</seg>
      </tuv>
      <tuv lang="JA">
        <seg>9.4.4  公開鍵認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Password Authentication</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスワード認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Host-Based Authentication</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホストベース認証</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクション プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End Point Security</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エンドポイントのセキュリティ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End point security is assumed by the connection protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルは, エンドポイントのセキュリティを前提とする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxy Forwarding</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポート転送</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Secure Shell (SSH) Transport Layer Protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュア シェル (SSH) トランスポート層プロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Setup</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接続のセットアップ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH works over any 8-bit clean, binary-transparent transport.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH は, 8-bit クリーンでバイナリ透過などんなトランスポート上でも動作する. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client initiates the connection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントが, 接続を開始する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use over TCP/IP</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TCP/IP上での利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Version Exchange</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルバージョンの交換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This identification string MUST be</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この接続文字列は, 次の形式でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The null character MUST NOT be sent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>null 文字は送られてはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As such, an example of a valid identification string is</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正しい識別文字列の例は以下だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key exchange will begin immediately after sending this identifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この識別子を送ったらすぐに鍵交換が始まる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compatibility With Old SSH Versions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>古い SSH のバージョンとの互換性</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>During the transition period, it is important to be able to work in a</seg>
      </tuv>
      <tuv lang="JA">
        <seg>移行期間では, プロトコルのより古いバージョンを利用するインストール済みの SSH のクライアントやサーバと互換する方法で動作できることが重要だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Old Client, New Server</seg>
      </tuv>
      <tuv lang="JA">
        <seg>古いクライアントで新しいサーバ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New Client, Old Server</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいクライアントで古いサーバ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Packet Size and Overhead</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パケットのサイズとオーバーヘッド</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The minimum size of a TCP/IP header is 32 bytes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  TCP/IPのヘッダの最小サイズは, 32 byteだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the increase is no more than 5 bytes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このため, 増大は, 5byteよりも大きくならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also issues related to the maximum packet size.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最大のパケットサイズに関連する問題もある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary Packet Protocol</seg>
      </tuv>
      <tuv lang="JA">
        <seg> バイナリパケットプロトコル</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each packet is in the following format:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パケットは以下のフォーマットに従う:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>larger.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There MUST be at least four bytes of padding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>少なくとも 4 byte のパディングをしなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Maximum Packet Length</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最大パケット長</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compression</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption will be done after compression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮のあとで, 暗号化が行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compression MAY be stateful, depending on the method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮は, 方法によってはステートフルでもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following compression methods are currently defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の圧縮アルゴリズムが現在定義されている:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;zlib&quot; compression is described in [RFC1950] and in [RFC1951].</seg>
      </tuv>
      <tuv lang="JA">
        <seg> &quot;zlib&quot; 圧縮は, [RFC1950] と [RFC1951] に記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ciphers in each direction MUST run independently of each other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの通信の方向の暗号は, お互いに独立に動作しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following ciphers are currently defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在次の暗号が定義されている:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a block cipher with 8-byte blocks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, 8byteブロックのブロック暗号だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This version uses a 256-bit key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このバージョンは, 256-bitの鍵を用いる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;aes192-cbc&quot; cipher is the same as above, but with a 192-bit key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;aes192-cbc&quot; 暗号は, 同様の暗号だが, 192-bit の鍵を使う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;aes128-cbc&quot; cipher is the same as above, but with a 128-bit key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;aes128-cbc&quot; 暗号は, 同様の暗号だが, 128-bit の鍵を使う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;arcfour&quot; cipher is the Arcfour stream cipher with 128-bit keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;arcfour&quot; 暗号は, 128-bit鍵を用いる Arcfour(Alleged RC4) ストリーム暗号だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;idea-cbc&quot; cipher is the IDEA cipher in CBC mode [SCHNEIER].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;idea-cbc&quot; 暗号は, CBCモードの IDEA 暗号だ [SCHNEIER].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;none&quot; algorithm specifies that no encryption is to be done.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;none&quot; アルゴリズムは, 暗号化が行なわれないことを指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following MAC algorithms are currently defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下の MAC アルゴリズムが現在定義されている:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;hmac-*&quot; algorithms are described in [RFC2104].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;hmac-*&quot; アルゴリズムは, [RFC2104] に記述されている..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SHA-1 is described in [FIPS-180-2] and MD5 is described in [RFC1321].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SHA-1 は [FIPS-180-2] に, MD5 は [RFC1321] に記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Exchange Methods</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two REQUIRED key exchange methods have been defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2つの要求されている鍵交換法が定義されている:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These methods are described in Section 8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの方法は, 8 節に記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional methods may be defined as specified in [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加の方法が, [SSH-NUMBERS] で定義されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public Key Algorithms</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵アルゴリズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several aspects that define a public key type:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵の種類を定義するいくつかの側面がある:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Signature and/or encryption algorithms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  署名と/ないし暗号化アルゴリズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Encoding of signatures and/or encrypted data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  署名のエンコーディングと/ないし暗号化されたデータ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Certificates and public keys are encoded as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>証明書と公開鍵は次のようにエンコードされる:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signatures are encoded as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>署名は次のようにエンコードされる:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;ssh-dss&quot; key format has the following specific encoding:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;ssh-dss&quot; 鍵フォーマットは次のような特有のエンコーディングを持つ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting signature is encoded as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>署名の結果次のようにエンコードされる:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;ssh-rsa&quot; key format has the following specific encoding:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;ssh-rsa&quot; 鍵フォーマットは次のような特有のエンコーディングを持つ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the 'e' and 'n' parameters form the signature key blob.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで, パラメータ 'e', 'n' は署名のkey blob を生成する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method indicates that the key is an RSA-key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方法は, 鍵がRSA鍵であることを示している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Exchange</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each side MAY guess</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The guess is considered wrong if:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>推測は以下の場合に間違っていると考えられる:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Algorithm Negotiation</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズムのネゴシエーション</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key exchange begins by each side sending the following packet:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換は, それぞれの側が次のパケットを送ることで開始する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each name-list MUST contain at least one algorithm name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの名前リストは, 少なくとも1つのアルゴリズム名を含まなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+  the server also supports the algorithm,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>+  サーバもそのアルゴリズムをサポートしている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MAC algorithm names are listed in Section 6.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MAC アルゴリズム名は, 6.4 節に挙げられている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both parties MAY ignore this name-list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの側もこの名前リストを無視してよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Specific key exchange method messages (30 to 49).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  鍵交換法特有のメッセージ (30 to 49).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The provisions of Section 11 apply to unrecognized messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>11 節の規定が, 認識されないメッセージに適用される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output from Key Exchange</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換からの出力</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we'll call it HASH.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで, これを HASH とする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;A&quot; means the single character A, ASCII 65).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;A&quot; は, 単一の文字 A ASCII 65を意味する).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Initial IV server to client: HASH(K || H || &quot;B&quot; || session_id)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  サーバからクライアントへの初期 IV: HASH(K || H || &quot;B&quot; || session_id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Encryption key client to server: HASH(K || H || &quot;C&quot; || session_id)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  クライアントからサーバへの暗号鍵: HASH(K || H || &quot;C&quot; || session_id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Encryption key server to client: HASH(K || H || &quot;D&quot; || session_id)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  サーバからクライアントへの暗号鍵: HASH(K || H || &quot;D&quot; || session_id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Integrity key client to server: HASH(K || H || &quot;E&quot; || session_id)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  クライアントからサーバへの完全性のための(MACの)鍵: HASH(K || H || &quot;E&quot; || session_id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Integrity key server to client: HASH(K || H || &quot;F&quot; || session_id)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  サーバからクライアントへの完全性のための(MACの)鍵: HASH(K || H || &quot;F&quot; || session_id)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key data MUST be taken from the beginning of the hash output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵データは, ハッシュの出力の先頭から取得されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>式で表現すると次のようになる:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taking Keys Into Use</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の利用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key exchange ends by each side sending an SSH_MSG_NEWKEYS message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換は, それぞれの側が SSH_MSG_NEWKEYS メッセージを送ることで終了する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message is sent with the old keys and algorithms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージは, 古い鍵とアルゴリズムで送られる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Diffie-Hellman Key Exchange</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Diffie-Hellman 鍵交換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following steps are used to exchange a key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵を交換するために次の手順が使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C sends e to S.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C は S に e を送る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S receives e.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S は e を受け取る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is implemented with the following messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, 次のメッセージ群で実装される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, the client sends the following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>まず, クライアントは次のメッセージを送る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server then responds with the following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは次のメッセージで応答する:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Re-Exchange</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の再交換</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Service Request</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サービスの要求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the key exchange, the client requests a service.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換の後で, クライアントはサービスを要求する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently, the following names have been reserved:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在, 次の名前が予約されている:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional Messages</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加のメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either party may send any of the following messages at any time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの側も, 任意の時点で次のメッセージのどれかを送ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disconnection Message</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切断メッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message causes immediate termination of the connection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージ, 接続の即時の終了を起こす.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignored Data Message</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無視データメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Message</seg>
      </tuv>
      <tuv lang="JA">
        <seg> デバッグメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'message' doesn't need to contain a newline.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'message' は改行を含む必要はない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reserved Messages</seg>
      </tuv>
      <tuv lang="JA">
        <seg>予約されたメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such messages MUST be otherwise ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さもなければ, これらのメッセージは無視されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that numbers 30-49 are used for kex packets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>番号 30-49 が, 鍵交換のパケットに使われることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Secure Shell (SSH) Protocol Assigned Numbers</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュア シェル (SSH) プロトコルに割り当てられた番号(訳注: や名前)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Assignments .................................8</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期の割り当て .................................8</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document does not define any new protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, 新しいプロトコルは定義していない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Fields and Values</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルのフィールドと値</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol packets have message numbers in the range 1 to 255.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルのパケットは, 1から255の範囲のメッセージ番号を持つ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Assignments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期の割り当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future Assignments</seg>
      </tuv>
      <tuv lang="JA">
        <seg>将来の割り当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This range will be left for PRIVATE USE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この範囲は, プライベートな利用(PRIVATE USE)のために残されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disconnection Messages Reason Codes and Descriptions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切断メッセージの reason code (理由コード)と description(説明)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Disconnection Message 'reason code' is a uint32 value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切断メッセージの 'reason code' は uint32 の値だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are described in [SSH-TRANS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらは, [SSH-TRANS]で記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Channel Connection Failure Reason Codes and Descriptions</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネル接続失敗の reason code (理由コード)と description(説明)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Channel Connection Failure 'reason code' is a uint32 value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネル接続失敗の 'reason code' は uint32 の値だ. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is described in [SSH-CONNECT].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, [SSH-TRANS]で記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notes about the PRIVATE USE Range</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プライベートな利用(PRIVATE USE) の範囲についての注意</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended Channel Data Transfer data_type_code and Data</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張チャンネルデータ転送の data_type_code と data</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pseudo-Terminal Encoded Terminal Modes</seg>
      </tuv>
      <tuv lang="JA">
        <seg>擬似ターミナルの Encoded Terminal Modes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opcodes 1 to 159 have a uint32 argument.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1 から 159 までのオペコードは, uint32 の引数を1つ持つ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions for Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>命名規約</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A provision is made here for locally extensible names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルに拡張可能な名前についての準備が以下のようにされている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future Assignments of Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前の将来の割り当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Service Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サービス名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'service name' is used to describe a protocol layer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> 'service name' は, プロトコルの層を記述するのに使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Method Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証法の名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Assigned Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルに割り当てられる名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Channel Types</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルのチャンネルのタイプ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Global Request Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルのグローバルなリクエスト名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Channel Request Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルのチャンネルのリクエスト名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Assignment of Signal Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグナル名の初期の割り当て</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Subsystem Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルのサブシステムの名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Exchange Method Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換法の名前</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigned Algorithm Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>割り当て済みのアルゴリズム名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption Algorithm Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号アルゴリズム名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MAC Algorithm Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MACアルゴリズム名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public Key Algorithm Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵アルゴリズム名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compression Algorithm Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮アルゴリズム名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, インターネットコミュニティに対するインターネットの標準トラックプロトコルを定義している. また, 改善のための議論と示唆を求めている</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルの標準化の状態と状況は &quot;Internet
   Official Protocol Standards&quot; (STD 1) の現在の版を参照してほしい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Secure Shell (SSH) Protocol is a protocol for secure remote login
   and other secure network services over an insecure network.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュア シェル (SSH) プロトコルは, 安全ではないネットワーク上での安全なリモートログインや他の安全なネットワークサービスのためのプロトコルだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
   document describes the architecture of the SSH protocol, as well as
   the notation and terminology used in SSH protocol documents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, SSHのプロトコルのアーキテクチャを記述している. また, SSHのプロトコルのドキュメントで使われる表記法や用語も記述している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also
   discusses the SSH algorithm naming system that allows local
   extensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, ローカルな拡張を許可しているSSH アルゴリズムの命名規則も議論している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SSH protocol consists of three major components: The
   Transport Layer Protocol provides server authentication,
   confidentiality, and integrity with perfect forward secrecy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> SSH プロトコルは, 3つの主要な要素から構成されている: トランスポート層プロトコルは サーバの認証や, 機密性, 申し分なく転送を秘密にする完全性を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   User Authentication Protocol authenticates the client to the server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザ認証プロトコルは, クライアントをサーバに認証する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Connection Protocol multiplexes the encrypted tunnel into several
   logical channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルは暗号化されたトンネルをいくつかの論理的なチャンネルに多重化する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Details of these protocols are described in
   separate documents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのプロトコルの詳細は別々の文書に記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction ....................................................3
   2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イントロダクション ...............................................3
   2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Architecture ....................................................4
      4.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アーキテクチャ ................................................4
      4.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Host Keys ..................................................4
      4.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホスト鍵 ..................................................4
      4.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extensibility ..............................................6
      4.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張性 ..............................................6
      4.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Policy Issues ..............................................6
      4.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポリシーの問題 ..............................................6
      4.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security Properties ........................................7
      4.5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュリティの特性 ........................................7
      4.5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Localization and Character Set Support .....................7
   5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>地域化と文字セットのサポート .....................7
   5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Type Representations Used in the SSH Protocols .............8
   6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH プロトコルで利用されるデータ型の表現 .............8
   6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Algorithm and Method Naming ....................................10
   7.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズムと方式の命名規則 ....................................10
   7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Numbers ................................................11
   8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージ番号 ................................................11
   8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IANA Considerations ............................................12
   9.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANA の考慮 ............................................12
   9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security Considerations ........................................13
      9.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュリティの考察 ........................................13
      9.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pseudo-Random Number Generation ...........................13
      9.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>擬似乱数の生成 ...........................13
      9.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Control Character Filtering ...............................14
      9.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>制御文字のフィルタリング ...............................14
      9.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transport .................................................14
           9.3.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トランスポート .............................................14
           9.3.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Confidentiality ....................................14
           9.3.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>機密性....................................14
           9.3.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Integrity .....................................16
           9.3.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データの完全性 .....................................16
           9.3.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replay .............................................16
           9.3.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リプレイ(再送) ...................................16
           9.3.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Man-in-the-middle ..................................17
           9.3.5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>中間者 ..................................17
           9.3.5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Denial of Service ..................................19
           9.3.6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サービス妨害 ..................................19
           9.3.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Covert Channels ....................................20
           9.3.7.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コバートチャンネル(隠れチャンネル, プロトコルの想定外の手段で情報を伝えること)  ....................................20
           9.3.7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forward Secrecy ....................................20
           9.3.8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前方秘密性 ....................................20
           9.3.8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ordering of Key Exchange Methods ...................20
           9.3.9.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換法の注文 ...................20
           9.3.9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Traffic Analysis ...................................21
      9.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トラフィック解析 ...................................21
      9.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Protocol ...................................21
           9.4.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証プロトコル ...................................21
           9.4.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Weak Transport .....................................21
           9.4.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>弱いトランスポート ..................................21
           9.4.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Messages .....................................22
           9.4.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デバッグメッセージ ..................................22
           9.4.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Local Security Policy ..............................22
           9.4.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルなセキュリティポリシー ...................22
           9.4.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public Key Authentication ..........................23
           9.4.5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵認証 ..........................23
           9.4.5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Password Authentication ............................23
           9.4.6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスワード認証 ............................23
           9.4.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Host-Based Authentication ..........................23
      9.5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホストベース認証 ..........................23
      9.5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol .......................................24
           9.5.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクション プロトコル ....................................24
           9.5.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>End Point Security .................................24
           9.5.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エンドポイントのセキュリティ .......................24
           9.5.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proxy Forwarding ...................................24
           9.5.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポート転送 ...................................24
           9.5.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X11 Forwarding .....................................24
   10.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11 の転送 .....................................24
   10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Secure Shell (SSH) is a protocol for secure remote login and other
   secure network services over an insecure network.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュア シェル (SSH) は, 安全ではないネットワーク上での安全なリモートログインや他の安全なネットワークサービスのためのプロトコルだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It consists of
   three major components:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH は3つの主要な要素から構成されている:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The Transport Layer Protocol [SSH-TRANS] provides server
      authentication, confidentiality, and integrity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  トランスポート層プロトコル[SSH-TRANS] は, サーバの認証, 機密性, 完全性を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may optionally
      also provide compression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, オプションで圧縮も提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transport layer will typically be
      run over a TCP/IP connection, but might also be used on top of any
      other reliable data stream.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トランスポート層は, 典型的には TCP/IP接続の上で動くことを想定しているが, 他の信頼できるデータストリームの上で使ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The User Authentication Protocol [SSH-USERAUTH] authenticates the
      client-side user to the server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  ユーザ認証プロトコル [SSH-USERAUTH] は, クライアント側のユーザをサーバに認証する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It runs over the transport layer
      protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルはトランスポート層プロトコル上で動作する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The Connection Protocol [SSH-CONNECT] multiplexes the encrypted
      tunnel into several logical channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  コネクションプロトコル [SSH-CONNECT] は暗号化されたトンネルをいくつかの論理的なチャンネルに多重化する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It runs over the user
      authentication protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, ユーザ認証プロトコル上で動作する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client sends a service request once a secure transport layer
   connection has been established.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全なトランスポート層の接続が確立した時点で, クライアントはサービスの要求を送る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second service request is sent
   after user authentication is complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2番目のサービスの要求は, ユーザ認証が完了してから送られる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows new protocols to
   be defined and coexist with the protocols listed above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, 上に挙げたプロトコルと共存する, 新しいプロトコルが定義されることを許している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connection protocol provides channels that can be used for a wide
   range of purposes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルは, 広い範囲の目的に利用できるチャンネルを提供する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standard methods are provided for setting up
   secure interactive shell sessions and for forwarding (&quot;tunneling&quot;)
   arbitrary TCP/IP ports and X11 connections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>安全なインタラクティブなシェルのセッションを設定したり任意の TCP/IPポートやX11接続を転送(トンネリング)する標準的な方法が提供されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol fields and possible values to fill them are defined in this
   set of documents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルのフィールドとフィールドで取り得る値は , この文書群で定義される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol fields will be defined in the message
   definitions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージの定義で, プロトコルのフィールドは定義される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example, SSH_MSG_CHANNEL_DATA is defined as
   follows.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例として, SSH_MSG_CHANNEL_DATA を次で定義する</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Throughout these documents, when the fields are referenced, they will
   appear within single quotes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書群では, フィールドが参照される場合には, シングルクォートで囲まれて表記される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When values to fill those fields are
   referenced, they will appear within double quotes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フィールドに入る値が参照される場合は, ダブルクォートで囲まれて表記される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Using the above
   example, possible values for 'data' are &quot;foo&quot; and &quot;bar&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上の例を用いると, 'data' の取り得る値には, &quot;foo&quot; や &quot;bar&quot; がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hosts MAY have multiple
   host keys using multiple different algorithms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホストは異なるアリゴリズムを用いる複数のホスト鍵を持ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple hosts MAY
   share the same host key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のサーバで同じホスト鍵を共有してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a host has keys at all, it MUST have at
   least one key that uses each REQUIRED public key algorithm (DSS
   [FIPS-186-2]).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホストが鍵を持つなら, 少なくとも, 必須の公開鍵アルゴリズム(DSS [FIPS-186-2])を用いる鍵を1つ持たなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server host key is used during key exchange to verify that the
   client is really talking to the correct server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換の際にクライアントが本当に正しいサーバと通信しているかを検証するために, サーバのホスト鍵は使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this to be
   possible, the client must have a priori knowledge of the server's
   public host key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを可能にするために, クライアントはサーバの公開ホスト鍵をあらかじめ知っておく必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The client has a local database that associates each host name (as
      typed by the user) with the corresponding public host key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  クライアントは, (ユーザによって入力された)ホスト名と関連するホスト鍵を結びつけるデータベースを持つ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
      method requires no centrally administered infrastructure, and no</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方法は, 中央の管理されたインフラや第三者の調停が不要だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The downside is that the database of
      name-to-key associations may become burdensome to maintain.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前と鍵との関連のデータベースを管理するのがやっかいになるかもしれないのが, このやり方の欠点だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The host name-to-key association is certified by a trusted
      certification authority (CA).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  ホストの名前と鍵との関連を, 信頼された認証局(CA)が保証する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client only knows the CA root
      key, and can verify the validity of all host keys certified by
      accepted CAs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, CAのルート鍵のみを知っていれば受けいれているCAが保証したすべてのホスト鍵の正当性を検証できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second alternative eases the maintenance problem, since ideally
   only a single CA key needs to be securely stored on the client.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この2番目のやり方は, 管理の問題を軽減する. 理想的には単一のCAの鍵だけをクライアントで安全に保管するだけでよいからだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On
   the other hand, each host key must be appropriately certified by a
   central authority before authorization is possible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方で, それぞれのホスト鍵は, 認証を可能にする前に中央の認証局によって明示的に保証されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, a lot of
   trust is placed on the central infrastructure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて, 中央のインフラ上に多数の信用情報が置かれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol provides the option that the server name - host key
   association is not checked when connecting to the host for the first
   time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは, サーバ名とホスト鍵の関連を初回の接続時にはチェックしないという選択肢も提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows communication without prior communication of host
   keys or certification.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この選択肢を利用すると, あらかじめホスト鍵や信用についてやりとりせずに通信できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connection still provides protection
   against passive listening; however, it becomes vulnerable to active
   man-in-the-middle attacks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合でも接続は受動的な盗聴に対する保護を提供するが, 能動的な中間者攻撃に対しては脆弱になる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations SHOULD NOT normally allow
   such connections by default, as they pose a potential security
   problem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は通常このような接続をデフォルトでは許容しないほうがよい. 潜在的なセキュリティの問題をもたらすからだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, as there is no widely deployed key infrastructure
   available on the Internet at the time of this writing, this option
   makes the protocol much more usable during the transition time until
   such an infrastructure emerges, while still providing a much higher
   level of security than that offered by older solutions (e.g., telnet
   [RFC0854] and rlogin [RFC1282]).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら, 執筆時点でインターネット上に広く配置されている鍵基盤は存在しない. そのような基盤が現れるまでの移行期間では, この選択肢を選択することはプロトコルをより有用にする. さらに, この選択肢は, より古い解決策(たとえば, telnet [RFC0854] や rlogin [RFC1282])が提供するよりも高いセキュリティレベルを提供できる..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations SHOULD try to make the best effort to check host
   keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は, ホスト鍵を検査する最大限の努力を払う必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example of a possible strategy is to only accept a host key
   without checking the first time a host is connected, save the key in
   a local database, and compare against that key on all future
   connections to that host.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可能な方法の例として, 最初にホストに接続した際だけはチェックなしでホスト鍵を受け入れ, 鍵をローカルなデータベースに保存し, 以降のそのホストへのすべての接続では鍵を比較する, というものがある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations MAY provide additional methods for verifying the
   correctness of host keys, e.g., a hexadecimal fingerprint derived
   from the SHA-1 hash [FIPS-180-2] of the public key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>装はホスト鍵の正当性を検証する追加の方法を提供してもよい. たとえば, 公開鍵のSHA-1ハッシュ [FIPS-180-2] の16進の指紋だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such
   fingerprints can easily be verified by using telephone or other
   external communication channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このような指紋は, 電話や他の外部の通信チャンネルで容易に検証できる. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All implementations SHOULD provide an option not to accept host keys
   that cannot be verified.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての実装は, 検証できないホスト鍵を受け入れない選択を提供する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The members of this Working Group believe that 'ease of use' is
   critical to end-user acceptance of security solutions, and no
   improvement in security is gained if the new solutions are not used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このワーキンググループのメンバーは, '使い易さ'がセキュリティの解決策をエンドユーザに受け入れてもらうのに重要だと考えている. 新しい解決策が利用されないならば, セキュリティ上の改善は得られない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>believed to improve the overall security of the Internet, even though
   it reduces the security of the protocol in configurations where it is
   allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We believe that the protocol will evolve over time, and some
   organizations will want to use their own encryption, authentication,
   and/or key exchange methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは今後も発展していくし, また, いくつかの組織が彼らが作成した暗号化や認証や鍵交換法を利用したいと考えるだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Central registration of all extensions
   is cumbersome, especially for experimental or classified features.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての拡張を中央で登録することは面倒だ. 特に, 実験的な特徴や機密扱いのものにとってはそうだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, having no central registration leads to conflicts
   in method identifiers, making interoperability difficult.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方で, 中央での登録がないと方式の識別子に衝突がおきたり相互運用性が困難になってしまう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have chosen to identify algorithms, methods, formats, and
   extension protocols with textual names that are of a specific format.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>我々は, アルゴリズムや方式, フォーマット, 拡張プロトコルを特定の形式を持つテキスト名で識別することを選んだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>DNS names are used to create local namespaces where experimental or
   classified extensions can be defined without fear of conflicts with
   other implementations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>DNS名は, 他の実装との衝突の恐れなしに, 実験的あるいは機密扱いの拡張を定義するローカルな名前空間として利用される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One design goal has been to keep the base protocol as simple as
   possible, and to require as few algorithms as possible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>設計の目標の1つは, 基本のプロトコルを可能な限りシンプルに保ち必要なアルゴリズムを可能な限り少なくすることだ. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, all
   implementations MUST support a minimal set of algorithms to ensure
   interoperability (this does not imply that the local policy on all
   hosts would necessarily allow these algorithms).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, すべての実装は相互運用性を保証する最小限のアルゴリズムのセットをサポートしなければらならない(これはすべてのホストのローカルなポリシーがこれらのアルゴリズムを許可しなければならない, ということは意味しない).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mandatory
   algorithms are specified in the relevant protocol documents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装を義務付けられているアリゴリズムはそれぞれのプロトコルの文書で指定される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional algorithms, methods, formats, and extension protocols can
   be defined in separate documents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加のアルゴリズム, 方式, フォーマット, 拡張プロトコルは, 別のドキュメントで定義されることがある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See Section 6, Algorithm Naming,
   for more information.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>「セクション 6. アルゴリズムの命名」にさらなる情報がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol allows full negotiation of encryption, integrity, key
   exchange, compression, and public key algorithms and formats.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは, 暗号化や完全性, 鍵交換, 圧縮, 公開鍵のアルゴリズムのフォーマットについて, 完全にネゴシエーションすることができる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption, integrity, public key, and compression algorithms can be
   different for each direction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号化や完全性, 公開鍵, 圧縮のアルゴリズムは, 通信の方向によって異なってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following policy issues SHOULD be addressed in the configuration
   mechanisms of each implementation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のポリシーの問題を, それぞれの実装の設定メカニズムで扱う必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Encryption, integrity, and compression algorithms, separately for
      each direction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  通信の方向のそれぞれに対する暗号化や完全性, 圧縮のアルゴリズム</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The policy MUST specify which is the preferred
      algorithm (e.g., the first algorithm listed in each category).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ポリシーは, 優先されるアルゴリズムがなにかを指定しなければならない(たとえば, それぞれのカテゴリで最初に挙げられたアルゴリズム) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Public key algorithms and key exchange method to be used for host
      authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  ホスト認証で利用される公開鍵アルゴリズムと鍵交換法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The existence of trusted host keys for different
      public key algorithms also affects this choice.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なる公開鍵アルゴリズムを持つ複数の信頼されたホスト鍵が存在する場合もこの選択に影響する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The authentication methods that are to be required by the server
      for each user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  サーバがそれぞれのユーザに要求する認証法</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server's policy MAY require multiple
      authentication for some or all users.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバのポリシーは, 何人かないしすべてのユーザに対して複数の認証を必要としてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The required algorithms MAY
      depend on the location from where the user is trying to gain
      access.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要求されるアルゴリズムは, アクセスしようとするユーザの場所に依存してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The operations that the user is allowed to perform using the
      connection protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  コネクションプロトコルを利用してユーザに実行を許可する操作</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some issues are related to security; for
      example, the policy SHOULD NOT allow the server to start sessions
      or run commands on the client machine, and MUST NOT allow
      connections to the authentication agent unless forwarding such
      connections has been requested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの問題はセキュリティに関連している; 例えば,クライアントのマシン上でサーバがセッションを開始したりコマンドを実行したりするのをポリシーは許可しないほうがよいし, 転送が要求されていないのに認証エージェントへの接続をポリシーが許可してはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other issues, such as which
      TCP/IP ports can be forwarded and by whom, are clearly issues of
      local policy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TCP/IPのポートが転送できるかや誰に許可されるかといった他の問題は, 明らかにローカルなポリシーの問題だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of these issues may involve traversing or
      bypassing firewalls, and are interrelated with the local security
      policy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの問題の多くが, ファイアウォールの横断や回避に関与しており, ローカルなセキュリティポリシーと関連している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The primary goal of the SSH protocol is to improve security on the
   Internet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> SSH プロトコルの第一の目標は, インターネットのセキュリティを向上することだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It attempts to do this in a way that is easy to deploy,
   even at the cost of absolute security.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHは, 完全なセキュリティを犠牲にしてでも, 簡単に配置できるやり方でセキュリティを向上しようとする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  All encryption, integrity, and public key algorithms used are
      well-known, well-established algorithms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  すべての暗号, 完全性, 公開鍵アルゴリズムには, よく知られ確立したアルゴリズムを利用する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  All algorithms are used with cryptographically sound key sizes
      that are believed to provide protection against even the strongest
      cryptanalytic attacks for decades.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  すべてのアルゴリズムには, 最も強い暗号解析攻撃にさえ数十年の保護提供すると考えられr暗号学的に安全な鍵のサイズを利用する. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  All algorithms are negotiated, and in case some algorithm is
      broken, it is easy to switch to some other algorithm without
      modifying the base protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  すべてのアルゴリズムは取り決められる(ネゴシエーションされる). また, アルゴリズムが破られた場合, ベースのプロトコルを変更せずに他のアルゴリズムに簡単に変更できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specific concessions were made to make widespread, fast deployment
   easier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>広くすばやい配置を容易にするため, 仕様における妥協がおこなわれている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The particular case where this comes up is verifying that
   the server host key really belongs to the desired host; the protocol
   allows the verification to be left out, but this is NOT RECOMMENDED.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この具体的な例が, サーバホスト鍵が本当に接続したいホストかどうかの検証にある. プロトコルは, 検証を省略することを許可している. しかし, これは推奨されないやり方だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is believed to significantly improve usability in the short
   term, until widespread Internet public key infrastructures emerge.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(訳注: とはいえ, ) 広範なインターネット鍵基盤が現われるまでの短い期間, このやり方は非常に利便性を向上すると考えられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the most part, the SSH protocols do not directly pass text that
   would be displayed to the user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの部分で, SSH プロトコルはユーザに表示されるテキストを直接には扱わない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are some places where
   such data might be passed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら,そのようなデータが扱われる場所がいくつかある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In most places, ISO-10646
   UTF-8 encoding is used [RFC3629].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ほとんどの場合, ISO-10646
   UTF-8 エンコーディングが使われる [RFC3629].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When applicable, a field is also
   provided for a language tag [RFC3066].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可能な場合, 言語タグのためのフィールドも提供される. [RFC3066].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There
   is no clear solution, as different applications may display data in
   different formats.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明確な解決法はない. 異なるアプリケーションは異なる形式でデータを表示するかもしれないからだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different types of terminal emulation may also be
   employed in the client, and the character set to be used is
   effectively determined by the terminal emulation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なる端末エミュレーションのタイプがクライアントで用いられることがある. また, 端末エミュレーションによって利用される文字セットが事実上決定される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, no place is
   provided for directly specifying the character set or encoding for
   terminal session data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このため, 端末セッションのデータの文字セットやエンコーディングを直接指定する方法は提供されない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the terminal emulation type (e.g.,
   &quot;vt100&quot;) is transmitted to the remote site, and it implicitly
   specifies the character set and encoding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, (&quot;vt100&quot;のような) 端末エミュレーションの種類は,リモートサイトに転送され, これは文字セットやエンコーディングを暗黙のうちに指定する. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applications typically use
   the terminal type to determine what character set they use, or the
   character set is determined using some external means.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アプリケーションは, 利用する文字セットを決定するために端末タイプを典型的に利用する. もしくは, 文字セットは他の外部の方法によって決定される</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terminal
   emulation may also allow configuring the default character set.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>端末エミュレーションは, デフォルトの文字セットを設定することを許可するかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
   any case, the character set for the terminal session is considered
   primarily a client local issue.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どの場合でも, 端末セッションの文字セットは, 第一にクライアントのローカルな問題と考えられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal names used to identify algorithms or protocols are normally
   never displayed to users, and must be in US-ASCII.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルトリズムやプロトコルを指定するのに使われる内部名は, 通常ユーザには表示されない. またUS-ASCIIでなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client and server user names are inherently constrained by what
   the server is prepared to accept.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントとサーバのユーザ名は, 本質的にサーバが受け入れられるものに制限される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They might, however, occasionally
   be displayed in logs, reports, etc.  They MUST be encoded using ISO
   10646 UTF-8, but other encodings may be required in some cases.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, これらは時にはログやレポートなどに表示される. これらは,ISO 10646 UTF-8 を用いてエンコードされなければならない. しかし, 時には別のエンコーディングが必要とされる. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
   is up to the server to decide how to map user names to accepted user
   names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザ名を受け付けるものにどのようにマッピングするかは, サーバに委ねられている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For localization purposes, the protocol attempts to minimize the
   number of textual messages transmitted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>地域化の目的のために , プロトコルは転送されるテキストメッセージの数を最小にするようにしている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When present, such messages
   typically relate to errors, debugging information, or some externally
   configured data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>現在, これらのメッセージは典型的にはエラーやデバッグ情報, その他の外部で設定されるデータに関連している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For data that is normally displayed, it SHOULD be
   possible to fetch a localized message instead of the transmitted
   message by using a numerical code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常表示されるデータに対して, 転送されるメッセージの代りに地域化されたメッセージを数値コードを用いて取得できるようにする必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remaining messages SHOULD be
   configurable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>残りのメッセージは, 設定可能とする必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fixed length
      data is sometimes represented as an array of bytes, written
      byte[n], where n is the number of bytes in the array.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Fixed length
      固定長のデータは, byteの配列として表現されることがある. このとき, byte[n]と表記される. n は配列中のbyteの数だ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value 0
      represents FALSE, and the value 1 represents TRUE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値 0 が FALSE を表し, 値 1 が TRUE を表す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All non-zero
      values MUST be interpreted as TRUE; however, applications MUST NOT
      store values other than 0 and 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての 0 でない値は TRUE と解釈されなければならない.; しかし, アプリケーションは, 0 か 1 以外の値を格納してはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored as four bytes in the
      order of decreasing significance (network byte order).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>位が減少する順の4byteの値として格納される(ネットワークバイトオーダー)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
      example: the value 699921578 (0x29b7f4aa) is stored as 29 b7 f4
      aa.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例:  699921578 (0x29b7f4aa) は is 29 b7 f4 aa として格納される..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Stored as eight bytes in
      the order of decreasing significance (network byte order).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>位が減少する順の8byteの値として格納される(ネットワークバイトオーダー)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings are allowed to contain
      arbitrary binary data, including null characters and 8-bit
      characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>stringは, nullや8-bitの文字も含む, 任意のバイナリデータを保持できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are stored as a uint32 containing its length
      (number of bytes that follow) and zero (= empty string) or more
      bytes that are the value of the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>stringは, その長さ(値のbyte数)のuint32とその値のbyte列によって格納される. 空のstringの場合は, 値がない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Terminating null
      characters are not used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>null 文字による終端は利用されない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, US-ASCII is
      used for internal names, and ISO-10646 UTF-8 for text that might
      be displayed to the user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この時, 内部の名前には US-ASCIIが利用される. また, ISO-10646 UTF-8 がユーザに表示される可能性のあるテキストとして利用される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The terminating null character SHOULD
      NOT normally be stored in the string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>終端のnull 文字は, 通常はstringには格納しないほうがよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example: the US-ASCII
      string &quot;testing&quot; is represented as 00 00 00 07 t e s t i n g.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例: US-ASCIIのstring &quot;testing&quot; は 00 00 00 07 t e s t i n g として表現される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
      UTF-8 mapping does not alter the encoding of US-ASCII characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>UTF-8 のマッピングは, US-ASCIIの文字のエンコーディングを変更しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Represents multiple precision integers in two's complement format,
      stored as a string, 8 bits per byte, MSB first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2 の補数形式の多倍精度整数. string 形式で, byteごとに8 bit,  MSB(最上位ビット)が先頭の形式で格納される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Negative numbers
      have the value 1 as the most significant bit of the first byte of
      the data partition.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>負の数は, データパーティションの最初のバイトの最上位ビットに1を持つ. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the most significant bit would be set for
      a positive number, the number MUST be preceded by a zero byte.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正の数に対して最上位ビットを設定したいならば, 0 のバイトを先行させなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unnecessary leading bytes with the value 0 or 255 MUST NOT be
      included.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0 か 255 の値の必要のない先行バイトは含めてはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value zero MUST be stored as a string with zero
      bytes of data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値 0 は, 0 バイトのデータの stringとして格納されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By convention, a number that is used in modular computations in
      Z_n SHOULD be represented in the range 0 &lt;= x &lt; n.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>慣習により, Z_nのモジュラ計算に利用される数は, 0 &lt;= x &lt; n の範囲で表現される必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value (hex)        representation (hex)
         -----------        --------------------
         0                  00 00 00 00
         9a378f9b2e332a7    00 00 00 08 09 a3 78 f9 b2 e3 32 a7
         80                 00 00 00 02 00 80
         -1234              00 00 00 02 ed cc
         -deadbeef          00 00 00 05 ff 21 52 41 11</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値 (hex)             表現 (hex)
         -----------        --------------------
         0                  00 00 00 00
         9a378f9b2e332a7    00 00 00 08 09 a3 78 f9 b2 e3 32 a7
         80                 00 00 00 02 00 80
         -1234              00 00 00 02 ed cc
         -deadbeef          00 00 00 05 ff 21 52 41 11</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A name-list
      is represented as a uint32 containing its length (number of bytes
      that follow) followed by a comma-separated list of zero or more
      names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>name-list は, 長さをbyte数で指定するuint32と それに続く0 ないしいくつかの name のカンマ区切りリストで表現される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A name MUST have a non-zero length, and it MUST NOT
      contain a comma (&quot;,&quot;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>name は 0でない長さでなければならない. また, カンマ (&quot;,&quot;) を含んではならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As this is a list of names, all of the
      elements contained are names and MUST be in US-ASCII.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>name のリストであるので, すべての含まれる要素は name だ. また US-ASCIIでなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Context may
      impose additional restrictions on the names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前後関係が, name に対するさらなる制約を課すかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the
      names in a name-list may have to be a list of valid algorithm
      identifiers (see Section 6 below), or a list of [RFC3066] language
      tags.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば, name-list中の name は, 正当なアルゴリズム識別子(セクション6以下参照)でなければならないかもしれないし , [RFC3066] 言語タグでなければならないかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order of the names in a name-list may or may not be
      significant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>name-listのnameの順序は, 重要かもしれないしそうでないかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, this depends on the context in which the list
      is used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, 重要度はリストが用いられる前後関係に依存する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Terminating null characters MUST NOT be used, neither
      for the individual names, nor for the list as a whole.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>終端のnull文字は, 個別のnameにも, リスト全体にも, 使ってはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>value                      representation (hex)
       -----                      --------------------
       (), the empty name-list    00 00 00 00
       (&quot;zlib&quot;)                   00 00 00 04 7a 6c 69 62
       (&quot;zlib,none&quot;)              00 00 00 09 7a 6c 69 62 2c 6e 6f 6e 65</seg>
      </tuv>
      <tuv lang="JA">
        <seg>値                         表現 (hex)
       -----                      --------------------
       (), 空の name-list         00 00 00 00
       (&quot;zlib&quot;)                   00 00 00 04 7a 6c 69 62
       (&quot;zlib,none&quot;)              00 00 00 09 7a 6c 69 62 2c 6e 6f 6e 65</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SSH protocols refer to particular hash, encryption, integrity,
   compression, and key exchange algorithms or methods by name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH プロトコルは, 特定のハッシュや暗号, 完全性, 圧縮, 鍵交換のアルゴリズムや方式を名前で参照する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There
   are some standard algorithms and methods that all implementations
   MUST support.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての実装がサポートしなければならない, いくつかの標準アルゴリズムと方式がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are also algorithms and methods that are defined
   in the protocol specification, but are OPTIONAL.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, プロトコルの仕様で定義されるアルゴリズムや実装がある. これらは選択できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Furthermore, it is
   expected that some organizations will want to use their own
   algorithms or methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, いくつかの組織が自身のアルゴリズムや方式を使いたいと求めることが予想される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this protocol, all algorithm and method identifiers MUST be
   printable US-ASCII, non-empty strings no longer than 64 characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルでは, すべてのアルゴリズムと方式の識別子は, 表示可能なUS-ASCIIで64文字以下の空でない string でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Names that do not contain an at-sign (&quot;@&quot;) are reserved to be
      assigned by IETF CONSENSUS.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  アットマーク &quot;@&quot; を含まない名前は, IETFの合意によって割当てられるために予約されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples include &quot;3des-cbc&quot;, &quot;sha-1&quot;,
      &quot;hmac-sha1&quot;, and &quot;zlib&quot; (the doublequotes are not part of the
      name).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば, &quot;3des-cbc&quot;, &quot;sha-1&quot;,
      &quot;hmac-sha1&quot;, &quot;zlib&quot; だ(ダブルクォーテーション '&quot;' は名前の一部ではない.).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names of this format are only valid if they are first
      registered with the IANA.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このフォーマットでの名前は, IANAによって最初に登録されたものだけが有効だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Registered names MUST NOT contain an
      at-sign (&quot;@&quot;), comma (&quot;,&quot;), whitespace, control characters (ASCII
      codes 32 or less), or the ASCII code 127 (DEL).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>登録された名前は, アットマーク(&quot;@&quot;), コンマ (&quot;,&quot;), スペース, 制御文字(ASCIIコード 32以下), ASCIIコードの127 (DEL)を含んではならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names are case-
      sensitive, and MUST NOT be longer than 64 characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前は大文字小文字が区別され, 64文字以下でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Anyone can define additional algorithms or methods by using names
      in the format name@domainname, e.g., &quot;ourcipher-cbc@example.com&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  name@domainname という形式の名前を用いて, だれでも追加のアルゴリズムや方式を定義できる. たとえば, &quot;ourcipher-cbc@example.com&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format of the part preceding the at-sign is not specified;
      however, these names MUST be printable US-ASCII strings, and MUST
      NOT contain the comma character (&quot;,&quot;), whitespace, control
      characters (ASCII codes 32 or less), or the ASCII code 127 (DEL).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アットマークの前の部分の形式は指定されていない; しかし, 表示可能な US-ASCIIの文字列で, コンマ (&quot;,&quot;), スペース, 制御文字(ASCIIコード 32以下), ASCIIコードの127 (DEL)を含んではならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The part following
      the at-sign MUST be a valid, fully qualified domain name [RFC1034]
      controlled by the person or organization defining the name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アットマークに続く部分は, 名前を定義する個人ないし組織で管理されている有効な完全に記述したドメイン名 [RFC1034]でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names
      are case-sensitive, and MUST NOT be longer than 64 characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前は大文字小文字が区別され, 64文字以下でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
      is up to each domain how it manages its local namespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルな名前空間をどう管理するかは, それぞれのドメイン次第だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It
      should be noted that these names resemble STD 11 [RFC0822] email
      addresses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この名前が, STD 11 [RFC0822]のメールアドレスと似ていることを明記しておく.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is purely coincidental and has nothing to do with
      STD 11 [RFC0822].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, 単なる偶然でありSTD 11 [RFC0822]とは関係ない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
   numbers have been allocated as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この番号は次のように割当てられる:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 to 19    Transport layer generic (e.g., disconnect, ignore,
                 debug, etc.)
      20 to 29   Algorithm negotiation
      30 to 49   Key exchange method specific (numbers can be reused
                 for different authentication methods)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1 to 19    トランスポート層一般(例: 切断, 無視, デバッグなど
      20 to 29   アルゴリズムのネゴシエーション
      30 to 49   鍵交換方式ごとに特有(番号は, 異なる方式で再利用されてもよい)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>50 to 59   User authentication generic
      60 to 79   User authentication method specific (numbers can be
                 reused for different authentication methods)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>50 to 59   ユーザ認証一般
      60 to 79   ユーザ認証法ごとに特有(番号は, 異なる方式で再利用されてもよい)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>80 to 89   Connection protocol generic
      90 to 127  Channel related messages</seg>
      </tuv>
      <tuv lang="JA">
        <seg>80 to 89   コネクションプロトコル一般
      90 to 127  チャンネルに関連したメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The instructions for the IANA for
   the SSH protocol, as defined in this document, [SSH-USERAUTH],
   [SSH-TRANS], and [SSH-CONNECT], are detailed in [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書,  [SSH-USERAUTH],
   [SSH-TRANS],  [SSH-CONNECT] で定義される SSH プロトコルに対する IANA への 指示は,  [SSH-NUMBERS] で詳述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   following is a brief summary for convenience, but note well that
   [SSH-NUMBERS] contains the actual instructions to the IANA, which may
   be superseded in the future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>便宜のために簡単なまとめを次に挙げる. しかし, [SSH-NUMBERS]は, IANA への実際の指示を含んでいる. これは, 将来置き換えられるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Allocation of the following types of names in the SSH protocols is
   assigned by IETF consensus:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH プロトコルの次の種類の名前の割当ては, IETFの合意で行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Service Names
      *  Authentication Methods
      *  Connection Protocol Channel Names
      *  Connection Protocol Global Request Names
      *  Connection Protocol Channel Request Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  サービスの名前
      *  認証法
      *  コネクションプロトコルのチャンネル名
      *  コネクションプロトコルのグローバルなリクエスト名
      *  コネクションプロトコルのチャンネルリクエスト名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Assigned Algorithm Names
      *  Encryption Algorithm Names
      *  MAC Algorithm Names
      *  Public Key Algorithm Names
      *  Compression Algorithm Names</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  割当てられたアルゴリズムの名前
      *  暗号アルゴリズム名
      *  MACアルゴリズム名
      *  公開鍵アルゴリズム名
      *  圧縮アルゴリズム名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These names MUST be printable US-ASCII strings, and MUST NOT contain
   the characters at-sign (&quot;@&quot;), comma (&quot;,&quot;), whitespace, control
   characters (ASCII codes 32 or less), or the ASCII code 127 (DEL).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの名前は, 表示可能なUS-ASCIIの文字列で,アットマーク(&quot;@&quot;), コンマ (&quot;,&quot;), スペース, 制御文字(ASCIIコード 32以下), ASCIIコードの127 (DEL)を含んではならない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names with the at-sign (&quot;@&quot;) are locally defined extensions and are
   not controlled by the IANA.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アットマーク(&quot;@&quot;) を持つ名前は, ローカルに定義された拡張で, IANAによって制御されない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, using the same name in multiple categories SHOULD be avoided
   to minimize confusion.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 複数のカテゴリで同じ名前を使うことは, 混乱を最小限にするために避ける必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message numbers (see Section 7) in the range of 0 to 191 are
   allocated via IETF CONSENSUS, as described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(セクション 7を参照) メッセージ番号 1 から 191 までの範囲は, IETFの合意により割当てられ. [RFC2434]に記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message
   numbers in the 192 to 255 range (local extensions) are reserved for
   PRIVATE USE, also as described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>192から255までの(ローカルな拡張の)メッセージ番号は, やはり [RFC2434]に記述されている, プライベートな利用(PRIVATE USE)に予約されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In order to make the entire body of Security Considerations more
   accessible, Security Considerations for the transport,
   authentication, and connection documents have been gathered here.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュリティに関する考察のすべての部分によりアクセスしやすくするため, トランスポート, 認証, コネクションの文書のセキュリティの考察をここに集約した</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transport protocol [SSH-TRANS] provides a confidential channel
   over an insecure network.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トランスポートプロトコル [SSH-TRANS] は, 安全でないネットワーク上で秘密のチャンネルを提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It performs server host authentication,
   key exchange, encryption, and integrity protection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバの認証, 鍵の交換, 暗号化, 完全性の保護を行なう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also derives
   a unique session id that may be used by higher-level protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, より上位のプロトコルで利用される, ユニークなセッションidを導出する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The authentication protocol [SSH-USERAUTH] provides a suite of
   mechanisms that can be used to authenticate the client user to the
   server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証プロトコル [SSH-USERAUTH] は, クライアントのユーザをサーバに認証するのに利用される一連のメカニズムを提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Individual mechanisms specified in the authentication
   protocol use the session id provided by the transport protocol and/or
   depend on the security and integrity guarantees of the transport
   protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証プロトコルで定義されるそれぞれのプロトコルは, トランスポートプロトコルで提供されるセッションidを利用したり, トランスポート層のセキュリティと完全性の保証に依存することがある. 両方を必要とする場合もある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The connection protocol [SSH-CONNECT] specifies a mechanism to
   multiplex multiple streams (channels) of data over the confidential
   and authenticated transport.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコル [SSH-CONNECT]は, 秘密で認証されたトランスポート上のデータの複数のストリームを多重化する メカニズムを定義する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also specifies channels for
   accessing an interactive shell, for proxy-forwarding various external
   protocols over the secure transport (including arbitrary TCP/IP
   protocols), and for accessing secure subsystems on the server host.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>また, インタラクティブなシェルにアクセスするチャンネル, 任意のTCP/IPプロトコルを含む外部のプロトコルを安全なトランスポート上でプロシキし転送するチャンネル, サーバホストの安全なサブシスムにアクセスするチャンネルを定義する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol binds each session key to the session by including
   random, session specific data in the hash used to produce session
   keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, セッション鍵を作成するのに使われるハッシュの中にランダムでセッション固有のデータを含むことで, セッション鍵をセッションに束縛する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Special care should be taken to ensure that all of the random
   numbers are of good quality.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての乱数がよい質であることを保証する特別な注意が払われなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the random data here (e.g., Diffie-
   Hellman (DH) parameters) are pseudo-random, then the pseudo-random
   number generator should be cryptographically secure (i.e., its next
   output not easily guessed even when knowing all previous outputs)
   and, furthermore, proper entropy needs to be added to the pseudo-
   random number generator.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし, ここで乱数(たとえば, Diffie-Hellman (DH) のパラメータ) が擬似乱数ならば, 擬似乱数生成器は暗号学的に安全でなければならない. (すなわち, 生成器の次の出力が, たとえ以前の出力をすべて知られていても, 簡単に推測されない) さらに, 適切なエントロピーが疑似乱数生成器に追加される必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[RFC4086] offers suggestions for sources of
   random numbers and entropy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>[RFC4086] は, 乱数とエントロピーについての示唆を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers should note the importance
   of entropy and the well-meant, anecdotal warning about the difficulty
   in properly implementing pseudo-random number generating functions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者は, エントロピーの重要性を注記する必要がある. また, 疑似乱数生成関数の正しい実装の難しさをわかりやすく事例付きで警告する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The amount of entropy available to a given client or server may
   sometimes be less than what is required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントやサーバで利用できるエントロピーの量が, 必要よりも少ないことがある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, one must
   either resort to pseudo-random number generation regardless of
   insufficient entropy or refuse to run the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合, 不十分なエントロピー量でもあえて疑似乱数生成を行なうかプロトコルを終了するかのどちらかを選択しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latter is
   preferable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後者のほうが好ましい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When displaying text to a user, such as error or debug messages, the
   client software SHOULD replace any control characters (except tab,
   carriage return, and newline) with safe sequences to avoid attacks by
   sending terminal control characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エラーやデバッグのメッセージのようなユーザにテキストを表示する際, クライアントのソフトウェアはタブとキャリッジリターン, 改行を除くすべての制御文字を安全なシーケンスに置換する必要がある. これは, 端末制御文字を送られることによる攻撃を避けるためだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is beyond the scope of this document and the Secure Shell Working
   Group to analyze or recommend specific ciphers other than the ones
   that have been established and accepted within the industry.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>業界内で確立され受け入れられている暗号のうち, どれが優れているか分析したり優れた暗号を推奨することは, この文書やセキュアシェルワーキンググループの範囲を超えている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the
   time of this writing, commonly used ciphers include 3DES, ARCFOUR,
   twofish, serpent, and blowfish.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>執筆時点では, 広く利用されている暗号には, 3DES, ARCFOUR, twofish, serpent, blowfish がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>AES has been published by The US
   Federal Information Processing Standards as [FIPS-197], and the
   cryptographic community has accepted AES as well.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>AESは US Federal Information Processing Standards as [FIPS-197] として公開され, また暗号学のコミュニティも同様にAESを受け入れた.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As always,
   implementers and users should check current literature to ensure that
   no recent vulnerabilities have been found in ciphers used within
   products.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者とユーザは, 常に, 製品に利用している暗号に新しい脆弱性が見付かっていないことを保証するために最近の文献をチェックする必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers should also check to see which ciphers are
   considered to be relatively stronger than others and should recommend
   their use to users over relatively weaker ciphers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者は, さらに, どの暗号が相対的に優れているかチェックし相対的に弱い暗号を利用しているユーザに優れている暗号の利用を勧める必要がある</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It would be
   considered good form for an implementation to politely and
   unobtrusively notify a user that a stronger cipher is available and
   should be used when a weaker one is actively chosen.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より弱い暗号があえて選択されている場合に, より強い暗号が利用できかつ利用されるべきであることをていねいにでしゃばらずにユーザに知らせるのが, 実装としてよいあり方だろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;none&quot; cipher is provided for debugging and SHOULD NOT be used
   except for that purpose.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;none&quot; 暗号は, デバッグのために提供されている. これ以外の目的に利用しないほうがよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its cryptographic properties are
   sufficiently described in [RFC2410], which will show that its use
   does not meet the intent of this protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;none&quot; の性質は, [RFC2410]に詳述されている. &quot;none&quot; の利用はこのプロトコルの目的に一致しないことが示されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The relative merits of these and other ciphers may also be found in
   current literature.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号ごとの相対的なメリットについては最近の文献に記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two references that may provide information on
   the subject are [SCHNEIER] and [KAUFMAN].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この件で情報を提供してくれる2つの文献が [SCHNEIER] と [KAUFMAN] だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both of these describe the
   CBC mode of operation of certain ciphers and the weakness of this
   scheme.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらはともに, 特定の暗号を利用するCBCモードとこの方式の弱点を記述している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Essentially, this mode is theoretically vulnerable to chosen
   cipher-text attacks because of the high predictability of the start
   of packet sequence.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本来, このモードは, 選択暗号文攻撃に理論的に脆弱だ. パケット列の先頭が高い確率で予測できるからだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this attack is deemed difficult and not
   considered fully practicable, especially if relatively long block
   sizes are used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 特に長めのブロックサイズを利用している場合には, この攻撃は難しいと考えられ十分に実行可能とはみなされていない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, another CBC mode attack may be mitigated through the
   insertion of packets containing SSH_MSG_IGNORE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, SSH_MSG_IGNORE を含むパケットを挿入することで, 別種のCBCモードへの攻撃は和らげられる. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Without this
   technique, a specific attack may be successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このテクニックがなしでは, 特定の攻撃は成功するだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this attack
   (commonly known as the Rogaway attack [ROGAWAY], [DAI], [BELLARE]) to
   work, the attacker would need to know the Initialization Vector (IV)
   of the next block that is going to be encrypted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Rogaway attack [ROGAWAY], [DAI], [BELLARE] として知られるこの攻撃のためには, 攻撃者は次の暗号化されるブロックの初期化ベクトル(IV)を知る必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In CBC mode that is
   the output of the encryption of the previous block.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CBCモードでは, これは前のブロックの暗号化の出力だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the attacker
   does not have any way to see the packet yet (i.e., it is in the
   internal buffers of the SSH implementation or even in the kernel),
   then this attack will not work.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>攻撃者がパケット(すなわち, SSHの実装やOSのカーネル中の内部バッファ)を見る方法がなければ, この攻撃はできない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the last packet has been sent out
   to the network (i.e., the attacker has access to it), then he can use
   the attack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最後のパケットがネットワークに送られる(すなわち攻撃者がアクセスできる)と, 攻撃者は攻撃を利用できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the optimal case, an implementer would need to add an extra packet
   only if the packet has been sent out onto the network and there are
   no other packets waiting for transmission.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もっともよい対処法が, パケットがネットワーク上に送信されさらなる転送パケットがない場合に, 実装者は別のパケットを追加することだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers may wish to
   check if there are any unsent packets awaiting transmission;
   unfortunately, it is not normally easy to obtain this information
   from the kernel or buffers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者は, 転送待ちの未送信パケットがあるかどうかチェックしたいだろうが, カーネルやバッファの情報を知るには通常容易ではない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are no unsent packets, then a
   packet containing SSH_MSG_IGNORE SHOULD be sent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>未送信パケットがない場合, SSH_MSG_IGNOREを含むパケットが送られる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a new packet is
   added to the stream every time the attacker knows the IV that is
   supposed to be used for the next packet, then the attacker will not
   be able to guess the correct IV, thus the attack will never be
   successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいパケットがストリームに追加されるたびに, 攻撃者は次のパケットに利用されるであろうIVを知る. それゆえ, 攻撃者が正しいIVを推測できなければ攻撃はけっして成功しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ----&gt;
       contains Record 1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ----&gt;
        Record 1 を含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP(seq=x, len=1000)            ----&gt;
       contains Records 1,2</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TCP(seq=x, len=1000)            ----&gt;
       Records 1,2 を含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Nagle algorithm + TCP retransmits mean that the two records
      get coalesced into a single TCP segment.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ナゲールアルゴリズムとTCPの再送で2つのレコードが1つのTCPセグメントに合体された.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Record 2 is not at the beginning of the TCP segment and never will
      be because it gets ACKed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Record 2 は, TCPセグメントの先頭ではなく今後も先頭にはならない. ACKが受け取られたからだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yet, the attack is possible because Record 1 has already been
      seen.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし,  Record 1 がすでに見られているので攻撃できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As this example indicates, it is unsafe to use the existence of
   unflushed data in the TCP buffers proper as a guide to whether an
   empty packet is needed, since when the second write() is performed
   the buffers will contain the un-ACKed Record 1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例が示すように, 空のパケットが必要かどうかのガイドとして TCPバッファに未送信のデータの存在を使うこと危険だ. 2番目のwrite()が実行されるとバッファにACKが受けとられていないRecord 1を含むからだ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, it is perfectly safe to have the following
   situation:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方, 次の場合は完全に安全だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ----&gt;
         contains SSH_MSG_IGNORE</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Client                                                  Server
      ------                                                  ------
      TCP(seq=x, len=500)             ----&gt;
         SSH_MSG_IGNORE を含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>TCP(seq=y, len=500)             ----&gt;
         contains Data</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TCP(seq=y, len=500)             ----&gt;
         Data を含む</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Provided that the IV for the second SSH Record is fixed after the
      data for the Data packet is determined, then the following should
      be performed:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Dataパケットのデータが決定してから2番目のSSH RecordのIVは決められる. 次の操作が実行される: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>read from user
         encrypt null packet
         encrypt data packet</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザから読み込み
         null パケットを暗号化
         data パケットを暗号化</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers SHOULD be wary of exposing this feature for any purpose
   other than debugging.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者は, デバッグ以外の目的でこの特徴を利用することに慎重な必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users and administrators SHOULD be explicitly
   warned anytime the &quot;none&quot; MAC is enabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザや管理者に, &quot;none&quot; MACが有効な時はいつでも明示的に警告する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So long as the &quot;none&quot; MAC is not used, this protocol provides data
   integrity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;none&quot; MAC が利用されない限り, このプロトコルはデータの完全性を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because MACs use a 32-bit sequence number, they might start to leak
   information after 2**32 packets have been sent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MACは32bitのシーケンス番号を利用するので, 2**32のパケットが送られたあとでは情報を漏らしはじめる. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, following
   the rekeying recommendations should prevent this attack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 次の鍵の再作成についての推奨が, この攻撃を防止するはずだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   transport protocol [SSH-TRANS] recommends rekeying after one gigabyte
   of data, and the smallest possible packet is 16 bytes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トランスポートプロトコル [SSH-TRANS] は, 1GBのデータごとに鍵の再作成を推奨している. また, 可能な最小のパケットを16byteにすることを推奨している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Therefore,
   rekeying SHOULD happen after 2**28 packets at the very most.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このため, 鍵の再作成は最も多くても2**28パケットごとに行なわれる必要がある. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of a MAC other than &quot;none&quot; provides integrity and
   authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;none&quot; 以外のMACは, 完全性と認証を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the transport protocol provides a
   unique session identifier (bound in part to pseudo-random data that
   is part of the algorithm and key exchange process) that can be used
   by higher level protocols to bind data to a given session and prevent</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて, トランスポートプロトコルは, ユニークなセッション識別子を提供する. (セッション識別子は, アルゴリズムと鍵交換のプロセスに必要な擬似乱数データにある程度束縛される) セッション識別子は, より上位のプロトコルで, データを特定のセッションに束縛し以前のセッションからのデータのリプレイを防ぐ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the authentication
   protocol ([SSH-USERAUTH]) uses this to prevent replay of signatures
   from previous sessions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば, 認証プロトコル ([SSH-USERAUTH]) は, セッション識別子を以前のセッションからの署名のリプレイの防止に利用する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because public key authentication exchanges
   are cryptographically bound to the session (i.e., to the initial key
   exchange), they cannot be successfully replayed in other sessions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵認証の交換が暗号学的にセッションと(すなわち最初の鍵交換と)束縛しているので, 別のセッションでのリプレイを成功させることができない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the session id can be made public without harming the
   security of the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッション識別子は, プロトコルのセキュリティを損なうことなく公開できることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If two sessions have the same session id (hash of key exchanges),
   then packets from one can be replayed against the other.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2つのセッションが同じセッション識別子(鍵交換のハッシュ)を持った場合, 一方からのパケットはもう一方に対してリプレイされる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It must be
   stressed that the chances of such an occurrence are, needless to say,
   minimal when using modern cryptographic methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強調されなければならないが, 現代の暗号技術を利用していればこのようなことが起こる可能性は, 言うまでもなく, ほとんどない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is all the
   more true when specifying larger hash function outputs and DH
   parameters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より大きなハッシュ関数の出力はDHのパラメータを定義した場合には, これはより確かになる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replay detection using monotonically increasing sequence numbers as
   input to the MAC, or HMAC in some cases, is described in [RFC2085],
   [RFC2246], [RFC2743], [RFC1964], [RFC2025], and [RFC4120].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MACや場合によってはHMACへの入力に単調に増加するシーケンス番号を用いるリプレイ検知は以下に記述されている. [RFC2085],
   [RFC2246], [RFC2743], [RFC1964], [RFC2025], [RFC4120].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   underlying construct is discussed in [RFC2104].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>基礎概念は, [RFC2104] で議論されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Essentially, a
   different sequence number in each packet ensures that at least this
   one input to the MAC function will be unique and will provide a
   nonrecurring MAC output that is not predictable to an attacker.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本来, それぞれのパケットで異なるシーケンス番号は, 少なくともMAC関数への1つの入力がユニークで攻撃者に予測不可能な再現することのないMACの出力を提供することを保証する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
   the session stays active long enough, however, this sequence number
   will wrap.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, セッションが十分に長く有効だと, このシーケンス番号が繰替えしてしまう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This event may provide an attacker an opportunity to
   replay a previously recorded packet with an identical sequence number
   but only if the peers have not rekeyed since the transmission of the
   first packet with that sequence number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このイベントは, 同一のシーケンス番号を持つ以前に記録したパケットを攻撃者がリプレイする機会を提供する. しかし, そのシーケンス番号の最初のパケットの転送からピアが鍵の再作成をしていない場合のみだ. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the peers have rekeyed,
   then the replay will be detected since the MAC check will fail.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ピアが鍵の再作成をしているなら, MACの検査が失敗してリプレイが検知される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
   this reason, it must be emphasized that peers MUST rekey before a
   wrap of the sequence numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このため, シーケンス番号が繰り返される前にピアは鍵の再作成をしなければならないことが強調されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, if an attacker does attempt
   to replay a captured packet before the peers have rekeyed, then the
   receiver of the duplicate packet will not be able to validate the MAC
   and it will be discarded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>当然, ピアが鍵の再作成をする前に捕獲したパケットを攻撃者はリプレイしようとすると, 複製されたパケットの受け取り手はMACの検証に失敗しパケットは捨てられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The reason that the MAC will fail is
   because the receiver will formulate a MAC based upon the packet
   contents, the shared secret, and the expected sequence number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MACが失敗する理由は, パケットの内容と共有の秘密, さらに期待されるシーケンス番号によって受け取り手がMACを編成するからだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since
   the replayed packet will not be using that expected sequence number
   (the sequence number of the replayed packet will have already been
   passed by the receiver), the calculated MAC will not match the MAC
   received with the packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リプレイされたパケットは, 期待されるシーケンス番号を利用していないので(リプレイされたパケットのシーケンス番号はすでに受け取り手に渡されている), 計算されたMACはパケットに含まれるMACと一致しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol makes no assumptions or provisions for an
   infrastructure or means for distributing the public keys of hosts.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルでは, ホストの公開鍵を配布する基盤や手段について仮定もしくは準備はない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is expected that this protocol will sometimes be used without
   first verifying the association between the server host key and the
   server host name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>場合によっては, サーバホスト鍵とサーバホスト名の関係を最初に検証すうことなしにこのプロトコルが利用されることが, 期待される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such usage is vulnerable to man-in-the-middle
   attacks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このような利用の仕方は, 中間者攻撃に脆弱だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and users to understand the importance of verifying this association
   before any session is initiated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   first is where an attacker places a device between the client and the
   server before the session is initiated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1つ目は,  セッション開始前にクライアントとサーバの間に攻撃者がデバイスを置いた場合だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the attack
   device is trying to mimic the legitimate server and will offer its
   public key to the client when the client initiates a session.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このとき, 攻撃用のデバイスは, 正当なサーバのふりをしようとする. そして, クライアントがセッションを開始しようとする際に, 自らの公開鍵をクライアントに送信する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it
   were to offer the public key of the server, then it would not be able
   to decrypt or sign the transmissions between the legitimate server
   and the client unless it also had access to the private key of the
   host.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>デバイスが正当なサーバの公開鍵を提供すると, 正当なサーバの秘密鍵にアクセスできなければ通信の復号や署名ができない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The attack device will also, simultaneously to this, initiate
   a session to the legitimate server, masquerading itself as the
   client.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>攻撃用のデバイスは, これと同時に, 正当なサーバへのセッションを開始する. このとき, デバイスはクライアントのふりをする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the public key of the server had been securely
   distributed to the client prior to that session initiation, the key
   offered to the client by the attack device will not match the key
   stored on the client.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッションの開始の前にサーバの公開鍵が安全にクライアントに配布されていれば, 攻撃用のデバイスがクライアントに提供した鍵とクライアイントが保持している鍵とが一致しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, the user SHOULD be given a
   warning that the offered host key does not match the host key cached
   on the client.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この時, 提供されたホスト鍵とクライアントにキャッシュされたホスト鍵が一致しないという警告をシステムはユーザに与える必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in Section 4.1, the user may be free to
   accept the new key and continue the session.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>4.1 節で記述したように, ユーザは新しい鍵を受け入れてセッションを継続してもよい. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is RECOMMENDED that
   the warning provide sufficient information to the user of the client
   device so the user may make an informed decision.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントデバイスは, ユーザが情報に基づく決定ができるように, 警告にユーザに対する十分な情報を提供することが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the user
   chooses to continue the session with the stored public key of the
   server (not the public key offered at the start of the session), then
   the session-specific data between the attacker and server will be
   different between the client-to-attacker session and the attacker-
   to-server sessions due to the randomness discussed above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザが, (セッションの開始時に提供された公開鍵ではなく) 保持していたサーバ公開鍵を用いてセッションを継続することを選択すると, 攻撃者とサーバの間のセッション固有のデータは,クライアントと攻撃者のセッションや(前述したランダム性のために)その他の攻撃者とサーバの間のセッションと異なる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From this,
   the attacker will not be able to make this attack work since the
   attacker will not be able to correctly sign packets containing this
   session-specific data from the server, since he does not have the
   private key of that server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これにより, 攻撃者にはサーバからのセッション固有のデータを含むパケットに正しく署名できない(秘密鍵を持っていないから)ので, 攻撃できない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second case that should be considered is similar to the first
   case in that it also happens at the time of connection, but this case
   points out the need for the secure distribution of server public
   keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>考慮すべきケースの2つ目は, 接続時に起こる1つ目の場合と似ている. この場合は, サーバ公開鍵の安全な配布の必要に目を向けさせる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server public keys are not securely distributed, then
   the client cannot know if it is talking to the intended server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバの公開鍵が安全に配布されないと, クライアントは目的のサーバと接続ているのかどうか知ることができない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An
   attacker may use social engineering techniques to pass off server
   keys to unsuspecting users and may then place a man-in-the-middle
   attack device between the legitimate server and the clients.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>攻撃者は, 疑いを持たないユーザに対してサーバの鍵の偽物をつかませるソーシャルエンジニアリングの技術を使い, そして正当なサーバとクライアントの間に中間者攻撃用のデバイスを配置するかもしれない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this
   is allowed to happen, then the clients will form client-to-attacker
   sessions, and the attacker will form attacker-to-server sessions and
   will be able to monitor and manipulate all of the traffic between the
   clients and the legitimate servers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>こうなると, クライアントはクライアント-攻撃者のセッションを作り, 攻撃者は攻撃者-サーバのセッションを作る. そして, 攻撃者はクライアントと正当なサーバのトラフィックを監視したり操作したりできるようになる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Server administrators are
   encouraged to make host key fingerprints available for checking by
   some means whose security does not rely on the integrity of the
   actual host keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバの管理者には, 実際のホスト鍵の完全性に依存しないセキュリティを持ついくつかの手段で, ホスト鍵の指紋を検査用に有効にしておくことが推奨される. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Possible mechanisms are discussed in Section 4.1
   and may also include secured Web pages, physical pieces of paper,</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可能は仕組みは, 4.1 節で議論されている. 安全なWebページや, 物理的な紙片などの方法がある. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>etc.  Implementers SHOULD provide recommendations on how best to do
   this with their implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者は, その実装で利用できる最良の仕組みへの推奨を提供する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the protocol is extensible,
   future extensions to the protocol may provide better mechanisms for
   dealing with the need to know the server's host key before
   connecting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは拡張可能なので, プロトコルの将来の拡張で, 接続前にサーバのホスト鍵を知る必要性を取り扱うよりより仕組みが提供されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, making the host key fingerprint available
   through a secure DNS lookup, or using Kerberos ([RFC4120]) over
   GSS-API ([RFC1964]) during key exchange to authenticate the server
   are possibilities.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば, ホスト鍵の指紋を安全なDNS検索によって利用可能にしたり, サーバを認証して鍵交換する間にGSS-API ([RFC1964])を使ってケルベロス [RFC4120]を利用するといった方法に, 可能性がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the third man-in-the-middle case, attackers may attempt to
   manipulate packets in transit between peers after the session has
   been established.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>3つ目のケースは, セッションが確立された後でピア間の通信のパケットを操作しようとするものだ.s after the session has
   been established.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As described in Section 9.3.3, a successful attack
   of this nature is very improbable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> 9.3.3節で述べたように, この手の攻撃が成功するのはほとんどありえない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As in Section 9.3.3, this
   reasoning does assume that the MAC is secure and that it is
   infeasible to construct inputs to a MAC algorithm to give a known
   output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>9.3.3節で挙げたように, この理由は MACが安全であることを仮定している. すなわち, 既知の出力に対するMACのアルゴリズムの入力を構築するのが困難であることを仮定している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is discussed in much greater detail in Section 6 of
   [RFC2104].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より詳しい議論が, [RFC2104]の 6 節にある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the MAC algorithm has a vulnerability or is weak
   enough, then the attacker may be able to specify certain inputs to
   yield a known MAC.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MACのアルゴリズムに脆弱性があったり弱い場合, 攻撃者は既知のMACの値を生成する入力を特定できるかもしれない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With that, they may be able to alter the contents
   of a packet in transit.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このとき, 攻撃者は通信中のパケットの内容を変更できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the attacker may be able to
   exploit the algorithm vulnerability or weakness to find the shared
   secret by reviewing the MACs from captured packets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あるいは, 攻撃者はキャプチャしたパケットのMACを吟味して共有の秘密を探すのにアルゴリズムの脆弱性や弱点を利用できるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In either of
   those cases, an attacker could construct a packet or packets that
   could be inserted into an SSH stream.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの場合も, 攻撃者はSSHのストリームに挿入できる1つないし複数のパケットを構成できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent this, implementers
   are encouraged to utilize commonly accepted MAC algorithms, and
   administrators are encouraged to watch current literature and
   discussions of cryptography to ensure that they are not using a MAC
   algorithm that has a recently found vulnerability or weakness.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを防ぐため, 実装者には, 一般に受け入れられているMACアルゴリズムを利用することが推奨される. また, 管理者には, 最近脆弱性や弱点が見つかったMACアルゴリズムを利用しないことを保証するために, 暗号学の最近の文献や議論を監視することが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In summary, the use of this protocol without a reliable association
   of the binding between a host and its host keys is inherently
   insecure and is NOT RECOMMENDED.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>まとめとして, ホストとそのホスト鍵の間に信頼できる関係がない場合にこのプロトコルを利用することは, 本質的に安全ではなく推奨されない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it may be necessary in
   non-security-critical environments, and will still provide protection
   against passive attacks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, これはセキュリティが重大事項ではない環境では必要であり, 受動的な攻撃に対する保護は提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers of protocols and applications
   running on top of this protocol should keep this possibility in mind.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルの上で動くプロトコルとアプリケーションの実装者は, この可能性を肝に銘じておくべきである.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
   transmission errors or message manipulation occur, the connection is
   closed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>転送エラーやメッセージの操作がおきると, 接続は終了される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Denial of service attacks of this type (wire cutter) are almost
   impossible to avoid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この種のサービス妨害攻撃(ワイヤカッター)はほぼ避けられない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, this protocol is vulnerable to denial of service attacks
   because an attacker can force the server to go through the CPU and
   memory intensive tasks of connection setup and key exchange without
   authenticating.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて, このプロトコルは, サービス妨害攻撃に対して脆弱だ. なぜなら,接続の設定や認証なしの鍵交換といったCPUやメモリをたくさん利用するタスクの実行を, 攻撃者がサーバに強制できるからだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>more difficult, for example, only allowing connections from a subset
   of clients known to have valid users.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
   example, the padding, SSH_MSG_IGNORE messages, and several other
   places in the protocol can be used to pass covert information, and
   the recipient has no reliable way of verifying whether such
   information is being sent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば, パディングやSSH_MSG_IGNOREメッセージや, またプロトコル中のいくつかの部分は, コバートチャンネルを転送するのに利用できる. 受け取り手には, そのような情報が送られたかどうかを検証する信頼できる方法はない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should be noted that the Diffie-Hellman key exchanges may provide
   perfect forward secrecy (PFS).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Diffie-Hellman 鍵交換は完全な前方秘密性(PFS)を提供できることを注記しておく.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PFS is essentially defined as the
   cryptographic property of a key-establishment protocol in which the
   compromise of a session key or long-term private key after a given
   session does not cause the compromise of any earlier session
   [ANSI-T1.523-2001].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>PFS は, 鍵確立プロトコルの暗号学的な性質として本来定義される. 鍵確立プロトコルにおいて, あるセッションでセッション鍵ないし長期間の秘密鍵が漏れても, それより前のセッションの情報は危険とならないという性質だ. [ANSI-T1.523-2001].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH sessions resulting from a key exchange using
   the diffie-hellman methods described in the section Diffie-Hellman
   Key Exchange of [SSH-TRANS] (including &quot;diffie-hellman-group1-sha1&quot;
   and &quot;diffie-hellman-group14-sha1&quot;) are secure even if private
   keying/authentication material is later revealed, but not if the
   session keys are revealed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>( &quot;diffie-hellman-group1-sha1&quot; と &quot;diffie-hellman-group14-sha1&quot; が含まれている)[SSH-TRANS]の Diffie-Hellman 鍵交換の節で記述されている diffie-hellman 法を用いる鍵交換を使ったSSHのセッションは, 共有鍵の生成法や認証の情報があとで漏れても安全だが, セッション鍵が漏れた場合は安全ではない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, given this definition of PFS, SSH
   does have PFS.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>よって, PFSの定義から, SSHはPFSという性質を持っている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this property is not commuted to any of the
   applications or protocols using SSH as a transport.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, この性質は, トランスポートとしてSSHを用いるアプリケーションやプロトコルのどれも変化させない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transport
   layer of SSH provides confidentiality for password authentication and
   other methods that rely on secret data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHのトランスポート層は, 秘密のデータに依存するパスワード認証や他の方法のための機密性を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Of course, if the DH private parameters for the client and server are
   revealed, then the session key is revealed, but these items can be
   thrown away after the key exchange completes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もちろん, クライアントやサーバのDHの秘密のパラメータが漏れたら, セッション鍵が漏れる. しかし, これらのパラメータは鍵交換が終わると捨てられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's worth pointing
   out that these items should not be allowed to end up on swap space
   and that they should be erased from memory as soon as the key
   exchange completes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのパラメータは, スワップ空間上に置くべきではなく, 鍵交換が終了したらメモリーから消されるべきだということは指摘しておく.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As stated in the section on Algorithm Negotiation of [SSH-TRANS],
   each device will send a list of preferred methods for key exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>[SSH-TRANS]のアルゴリズムネゴシエーションの節で述べるように, それぞれのデバイスは, 鍵交換について優先する方法のリストを送る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is
   RECOMMENDED that the algorithms be sorted by cryptographic strength,
   strongest first.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズムを暗号学的に最も強いものから降順に並べることを推奨する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some additional guidance for this is given in
   [RFC3766].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらなる助言が [RFC3766]で与えられている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Passive monitoring of any protocol may give an attacker some
   information about the session, the user, or protocol specific
   information that they would otherwise not be able to garner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>あらゆるプロトコルに対する受動的なモニタリングは, 攻撃者にセッションやユーザについての情報や, それ以外では集められないプロトコル特有の情報を与える場合がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
   example, it has been shown that traffic analysis of an SSH session
   can yield information about the length of the password - [Openwall]
   and [USENIX].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば, SSHのセッションのトラフィック解析によりパスワードの長さの情報が得られることが示されている.  - [Openwall] と [USENIX] を参照.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers should use the SSH_MSG_IGNORE packet,
   along with the inclusion of random lengths of padding, to thwart
   attempts at traffic analysis.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者は, トラフィック解析の試みを妨げるため, ランダムな長さのパディングと共にSSH_MSG_IGNOREパケットを使わなければならない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other methods may also be found and
   implemented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の方法も発見され実装されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of this protocol is to perform client user
   authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルの目標は, クライアントのユーザ認証を行なうことだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It assumes that this runs over a secure transport
   layer protocol, which has already authenticated the server machine,
   established an encrypted communications channel, and computed a
   unique session identifier for this session.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, すでにサーバマシンを認証し暗号化されたコミュニケーションチャンネルを確立しセンションのユニークな識別子を計算した, 安全なトランスポート層プロトコルの上で動くことを仮定している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Several authentication methods with different security
   characteristics are allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なるセキュリティの特質を持ったいくつかの認証法が許されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is up to the server's local policy
   to decide which methods (or combinations of methods) it is willing to
   accept for each user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのユーザに対して受け入れる方法(ないし方法の組合せ)を決定するのは, サーバのローカルなポリシーに委ねられている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication is no stronger than the weakest
   combination allowed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証の強さは, 最も弱い許可された方法(ないしその組合せ)の強さとなる. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server may go into a sleep period after repeated unsuccessful
   authentication attempts to make key search more difficult for
   attackers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>攻撃者にとって鍵の探索をより難しくするために, 認証の不成功が繰り返されたらサーバは休眠期間に入ってもよい</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Care should be taken so that this doesn't become a self-
   denial of service vector.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これが, 自己のサービス妨害を起こさないようにに注意する必要がある</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the transport layer does not provide confidentiality,
   authentication methods that rely on secret data SHOULD be disabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トランスポート層が機密性を提供していない場合は, 秘密のデータに依存する認証法は無効にされる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it does not provide strong integrity protection, requests to
   change authentication data (e.g., a password change) SHOULD be
   disabled to prevent an attacker from modifying the ciphertext without
   being noticed, or rendering the new authentication data unusable
   (denial of service).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>強い完全性保護が提供されない場合は, (パスワード変更のような)認証データの変更の要求は, 無効にされる必要がある. 攻撃者が警告無しに暗号文を変更したり新しい認証データを利用できないものに変更する(サービス妨害)のを防ぐためだ.
   (denial of service).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The assumption stated above, that the Authentication Protocol only
   runs over a secure transport that has previously authenticated the
   server, is very important to note.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証プロトコルはサーバを認証済みの安全なプロトコル上で働くという前述した仮定は, 非常に重要なので注記する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>People deploying SSH are reminded
   of the consequences of man-in-the-middle attacks if the client does
   not have a very strong a priori association of the server with the
   host key of that server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHを配置する際には, クライアントがサーバとそのホスト鍵が事前に強く結びついていない場合に起きる中間者攻撃の結果を把握すること.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifically, for the case of the
   Authentication Protocol, the client may form a session to a man-in-</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に, 認証プロトコルの場合は, クライアントが中間者攻撃用のデバイスとセッションを作るとユーザ名やパスワードといったユーザの認証資格を漏らしてしまう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the-middle attack device and divulge user credentials such as their
   username and password.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even in the cases of authentication where no
   user credentials are divulged, an attacker may still gain information
   they shouldn't have by capturing key-strokes in much the same way
   that a honeypot works.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザの認証資格を漏らさない認証の場合でも, 攻撃者はハニーポットと同様の働きにおりキーストロークをキャプチャし得られるべきではない情報を取得するかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
   messages may reveal surprising amounts of information about the host
   if not properly designed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのメッセージは, 適切に設計されていないとホストについての大量の情報を漏らしてしまう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug messages can be disabled (during
   user authentication phase) if high security is required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>高いセキュリティが要求されるなら, デバッグメッセージは(ユーザ認証のフェイズで)無効にできるようにする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Administrators of host machines should make all attempts to
   compartmentalize all event notification messages and protect them
   from unwarranted observation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホストの管理者は, すべてのイベント通知メッセージを区分けしメッセージを不当な監視から守るためにあらゆる試みを行なうべきだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Developers should be aware of the
   sensitive nature of some of the normal event and debug messages, and
   may want to provide guidance to administrators on ways to keep this
   information away from unauthorized people.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開発者は, 通常のイベントメッセージやデバッグメッセージのいくつかが重要な性質を持つことに注意しなければならない. そして, 不当な人間がこれらの情報に近づけないために管理者に手引きを提供しようとしてもよい. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Developers should
   consider minimizing the amount of sensitive information obtainable by
   users during the authentication phase, in accordance with the local
   policies.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開発者は, ローカルなポリシーに従って, 認証のフェイズでユーザが得られる重要な情報の量を最小化することを考慮すべきだ. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For this reason, it is RECOMMENDED that debug messages be
   initially disabled at the time of deployment and require an active
   decision by an administrator to allow them to be enabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの理由から, デバッグメッセージは配置時には無効にされていて, 管理者が能動的に有効する必要があることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also
   RECOMMENDED that a message expressing this concern be presented to
   the administrator of a system when the action is taken to enable
   debugging messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, デバッグメッセージを有効にする作業が行なわれた場合に, この懸念を表明するメッセージがシステムの管理者に提示されることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementer MUST ensure that the credentials provided validate
   the professed user and also MUST ensure that the local policy of the
   server permits the user the access requested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者は, 提供された認証情報でユーザを認証することを保証しなければならない. また, サーバのローカルなポリシーが, 要求されたアクセスをユーザに許すことを保証しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, because
   of the flexible nature of the SSH connection protocol, it may not be
   possible to determine the local security policy, if any, that should
   apply at the time of authentication because the kind of service being
   requested is not clear at that instant.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に, SSHコネクションプロトコルの柔軟な特徴のために, 認証の時点で適用されるべきローカルなセキュリティポリシーを決定することができないかもしれない. どのようなサービスが要求されるかは認証の時点では明らかではないからだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, local policy
   might allow a user to access files on the server, but not start an
   interactive shell.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば, ローカルなポリシーがユーザにサーバのファイルへのアクセスを許すがインタラクティブなシェルの開始は許さないとする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, during the authentication protocol, it
   is not known whether the user will be accessing files, attempting to
   use an interactive shell, or even both.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, ユーザがファイルにアクセスするかインタラクティブなシェルを使うか, その両方かは, 認証プロトコルの間にはわからない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any event, where local
   security policy for the server host exists, it MUST be applied and
   enforced correctly.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>とにかく, サーバホストにローカルなセキュリティポリシーがあるなら,  正しく適用/実施されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers are encouraged to provide a default local policy and
   make its parameters known to administrators and users.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者には, デフォルトのローカルポリシーを提供しそのパラメータを管理者とユーザに知らせることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the
   discretion of the implementers, this default policy may be along the
   lines of anything-goes where there are no restrictions placed upon
   users, or it may be along the lines of excessively-restrictive, in</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者の裁量で, このデフォルトのポリシーはユーザに何ら制限がない何でもありのものかもしれないし過剰なまでに制限されているかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which case, the administrators will have to actively make changes to
   the initial default parameters to meet their needs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後者の場合, 管理者は要件に添うようにデフォルトのパラメータを能動的に変更しなければならないだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively,
   it may be some attempt at providing something practical and
   immediately useful to the administrators of the system so they don't
   have to put in much effort to get SSH working.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしくは, システムの管理者がSSHを動作させるのに労力を払わずにすむように, デフォルトのポリシーが管理者にとって実際的ですぐに利用可能であろうと試みられているかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whatever choice is
   made must be applied and enforced as required above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どの選択がされようとも, 前述したように正しく適用され実施されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of public key authentication assumes that the client host has
   not been compromised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵認証の利用では, クライアントのホストが侵害されてないことを前提とする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also assumes that the private key of the
   server host has not been compromised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, サーバホストの秘密鍵も侵害されていないことも前提とする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This risk can be mitigated by the use of passphrases on private keys;
   however, this is not an enforceable policy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このリスクは, 秘密鍵にパスフレーズを付けることで緩和できるが, 強制できるポリシーではない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The use of smartcards,
   or other technology to make passphrases an enforceable policy is
   suggested.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスフレーズを強制可能なポリシーにできるスマートカードや他の技術の利用が示唆される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server could require both password and public key authentication;
   however, this requires the client to expose its password to the
   server (see the section on Password Authentication below.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, パスワード認証と公開鍵認証を同時に要求できる. しかし, このときクライアントはパスワードをサーバにさらす必要がある(次のパスワード認証の節を参照)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The password mechanism, as specified in the authentication protocol,
   assumes that the server has not been compromised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証プロトコルで定義されるパスワードのメカニズムは, サーバが侵害されていないことを前提とする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server has
   been compromised, using password authentication will reveal a valid
   username/password combination to the attacker, which may lead to
   further compromises.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバが侵害されている時にパスワード認証を利用すると, 攻撃者に正当なユーザ名とパスワードの組合せを示してしまう. これはさらなる侵害を生むかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This vulnerability can be mitigated by using an alternative form of
   authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この弱点は, 別の認証法を利用することで緩和できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, public key authentication makes no
   assumptions about security on the server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば, 公開鍵認証はサーバのセキュリティについては何ら前提を置かない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Host-based authentication assumes that the client has not been
   compromised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホストベース認証は, クライアントが侵害されていないことを前提とする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no mitigating strategies, other than to use
   host-based authentication in combination with another authentication
   method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>別の認証法とホストベースの認証を組合せる以外に, 緩和する方法はない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
   server has been compromised, any terminal sessions, port forwarding,
   or systems accessed on the host are compromised.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバが侵害されていると, あらゆる端末セッション, ポート転送, ホストにアクセスするシステムが, 侵害される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no
   mitigating factors for this.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これを緩和する要素はない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the client has been compromised, and the server fails to stop the
   attacker at the authentication protocol, all services exposed (either
   as subsystems or through forwarding) will be vulnerable to attack.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントが侵害されていると, 認証プロトコルでサーバが攻撃者を防止することができず, (サブシステムによるものや転送されるものも含む)公開されているすべてのサービスが攻撃に脆弱となる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers SHOULD provide mechanisms for administrators to control
   which services are exposed to limit the vulnerability of other
   services.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者は, サービスの弱点をさらさないためにどのサービスを公開するかを管理者が制御するメカニズムを提供する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These controls might include controlling which machines
   and ports can be targeted in port-forwarding operations, which users
   are allowed to use interactive shell facilities, or which users are
   allowed to use exposed subsystems.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制御は, ポート転送の操作でどのマシンやポートが対象となりうるかや, どのユーザがインタラクティブなシェルの機能の利用を許可されるかや, どのユーザが公開されているサブシステムの利用を許可されるかの制御も含むだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SSH connection protocol allows for proxy forwarding of other
   protocols such as SMTP, POP3, and HTTP.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH コネクションプロトコルは, SMTPやPOP3, HTTPといった別のプロトコルのプロキシ転送を許可する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This may be a concern for
   network administrators who wish to control the access of certain
   applications by users located outside of their physical location.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アプリケーションの物理的な位置以外からのユーザによるアプリケーションのアクセスを制御したいネットワーク管理者にとって, これは懸念事項だろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Essentially, the forwarding of these protocols may violate site-
   specific security policies, as they may be undetectably tunneled
   through a firewall.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>本質的に, これらのプロトコルの転送は, ファイアウォールを検知されずにトンネルしてしまうので, サイト特有のセキュリティポリシーを破ることになるだろう. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers SHOULD provide an administrative
   mechanism to control the proxy forwarding functionality so that
   site-specific security policies may be upheld.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装者は, サイト特有のセキュリティポリシーが守られるようにプロキシ転送機能を成業する管理メカニズムを提供する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, a reverse proxy forwarding functionality is available,
   which, again, can be used to bypass firewall controls.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて, 逆方向のプロキシ転送機能が有効だと, これもまたファイアウォールの制御を回避するのに利用されうる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As indicated above, end-point security is assumed during proxy
   forwarding operations.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前述のように , プロキシ転送の操作ではエンドポイントのセキュリティが前提とされる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failure of end-point security will compromise
   all data passed over proxy forwarding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エンドポイントのセキュリティに問題があると, プロキシ転送上で通信されるすべてのデータが侵害される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another form of proxy forwarding provided by the SSH connection
   protocol is the forwarding of the X11 protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH コネクションプロトコルが提供するプロキシ転送の別の形式が, X11 プロトコルの転送だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If end-point
   security has been compromised, X11 forwarding may allow attacks
   against the X11 server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>エンドポイントのセキュリティが侵害されていると, X11 転送はX11サーバへの攻撃を許してしまう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users and administrators should, as a matter
   of course, use appropriate X11 security mechanisms to prevent
   unauthorized use of the X11 server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザと管理者は, もちろん, X11サーバの不正な利用を防ぐために適切になX11のセキュリティメカニズムを利用しなけければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers, administrators,
   and users who wish to further explore the security mechanisms of X11
   are invited to read [SCHEIFLER] and analyze previously reported</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11のセキュリティメカニズムをさらに詳しく知りたい実装者と管理者, ユーザは [SCHEIFLER]を読みSSHの転送とX11の相互作用で以前報告された問題 (CERT
   vulnerabilities VU#363181 と VU#118892 [CERT])について分析することを勧める.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>problems with the interactions between SSH forwarding and X11 in CERT
   vulnerabilities VU#363181 and VU#118892 [CERT].</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X11 display forwarding with SSH, by itself, is not sufficient to
   correct well known problems with X11 security [VENEMA].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHによるX11ディスプレイの転送は, それ自体では, X11のセキュリティについて知られている問題 [VENEMA] を補正するのに十分ではない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, X11
   display forwarding in SSH (or other secure protocols), combined with
   actual and pseudo-displays that accept connections only over local
   IPC mechanisms authorized by permissions or access control lists
   (ACLs), does correct many X11 security problems, as long as the
   &quot;none&quot; MAC is not used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, &quot;none&quot; MACが使われない限り, SSH(ないし他の安全なプロトコル)でのX11のディスプレイの転送は, パーミッションないしアクセスコントロールリスト(ACL)によって認定された ローカルな IPC メカニズム上でのみ接続を受け付ける実際と擬似のディスプレイを組合せることで, 多くのX11のセキュリティ問題を修正する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is RECOMMENDED that X11 display
   implementations default to allow the display to open only over local
   IPC.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11のディスプレイの実装が, デフォルトではlocalのIPC上でのみディスプレイをオープンすることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is RECOMMENDED that SSH server implementations that support
   X11 forwarding default to allow the display to open only over local
   IPC.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11の転送をサポートするSSHのサーバの実装は, デフォルトではlocalのIPC上でのみディスプレイをオープンすることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On single-user systems, it might be reasonable to default to
   allow the local display to open over TCP/IP.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シングルユーザのシステムでは, デフォルトでローカルディスプレイをTCP/IP上でオープンすることが合理的かもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementers of the X11 forwarding protocol SHOULD implement the
   magic cookie access-checking spoofing mechanism, as described in
   [SSH-CONNECT], as an additional mechanism to prevent unauthorized use
   of the proxy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11転送プロトコルの実装者は, magic cookieのアクセスチェックをなりすますメカニズム ([SSH-CONNECT]に記述されている) を実装する必要がある. これは, プロキシの不正な利用を防止する追加のメカニズムだ. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document defines the instructions to the IANA and the initial
   state of the IANA assigned numbers for the Secure Shell (SSH)
   protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, セキュアシェル(SSH)プロトコルについてのIANAへの指示とIANAで割当てられる番号の初期状態を定義する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is intended only for the initialization of the IANA
   registries referenced in the set of SSH documents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHの文書群で参照されるIANAのレジストリの初期化のみを意図している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction ....................................................2
   2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イントロダクション ..........................................2
   2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Fields and Values .................................4
   4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルのフィールドと値..............................4
   4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IANA Considerations .............................................5
      4.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANA の考慮  .............................................5
      4.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message Numbers ............................................5
           4.1.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージ番号 .........................................5
           4.1.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions .........................................5
           4.1.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規約............................................5
           4.1.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Assignments .................................6
           4.1.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期の割り当て .................................6
           4.1.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future Assignments ..................................6
      4.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>将来の割り当て.................................6
      4.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disconnection Messages Reason Codes and Descriptions .......7
           4.2.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切断メッセージの reason code (理由コード)と description(説明)...7
           4.2.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions .........................................7
           4.2.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規約 .........................................7
           4.2.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Assignments .................................7
           4.2.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期の割り当て..................................7
           4.2.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future Assignments ..................................8
      4.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>将来の割り当て..................................8
      4.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Channel Connection Failure Reason Codes and Descriptions ...8
           4.3.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネル接続失敗の reason code (理由コード)と description(説明)..8
           4.3.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions .........................................8
           4.3.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規約 .........................................8
           4.3.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future Assignments ..................................8
           4.3.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>将来の割り当て ..................................8
           4.3.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notes about the PRIVATE USE Range ...................9
      4.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プライベートな利用(PRIVATE USE) の範囲についての注意.........9
      4.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended Channel Data Transfer data_type_code and Data .....9
           4.4.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張チャンネルデータ転送の data_type_code と data.....9
           4.4.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions .........................................9
           4.4.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規約 .........................................9
           4.4.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Assignments ................................10
           4.4.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期の割り当て ................................10
           4.4.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future Assignments .................................10
      4.5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>将来の割り当て.................................10
      4.5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pseudo-Terminal Encoded Terminal Modes ....................10
           4.5.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>擬似ターミナルの Encoded Terminal Modes...............10
           4.5.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions ........................................10
           4.5.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>規約 ........................................10
           4.5.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Assignments ................................10
           4.5.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期の割り当て................................10
           4.5.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future Assignments .................................12
      4.6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>将来の割り当て.................................12
      4.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names .....................................................12
           4.6.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前..................................................12
           4.6.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions for Names ..............................13
           4.6.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>命名規約..............................13
           4.6.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Future Assignments of Names ........................13
      4.7.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前の将来の割り当て........................13
      4.7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Service Names .............................................13
      4.8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サービス名............................................13
      4.8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Method Names ...............................14
      4.9.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証法の名前 ...............................14
      4.9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Assigned Names ........................14
           4.9.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルに割り当てられる名前............14
           4.9.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Channel Types ..................14
           4.9.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルのチャンネルのタイプ.....14
           4.9.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Global Request Names ...........14
           4.9.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルのグローバルなリクエスト名.....14
           4.9.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Channel Request Names ..........15
           4.9.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルのチャンネルのリクエスト名.......15
           4.9.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initial Assignment of Signal Names .................15
           4.9.5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグナル名の初期の割り当て.............15
           4.9.5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Protocol Subsystem Names ................15
      4.10.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルのサブシステムの名前.......15
      4.10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Exchange Method Names ................................16
      4.11.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換法の名前.................................16
      4.11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assigned Algorithm Names .................................16
           4.11.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>割り当て済みのアルゴリズム名.........................16
           4.11.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption Algorithm Names ........................16
           4.11.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号アルゴリズム名........................16
           4.11.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MAC Algorithm Names ...............................17
           4.11.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MACアルゴリズム名 ...............................17
           4.11.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public Key Algorithm Names ........................17
           4.11.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵アルゴリズム名 ........................17
           4.11.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compression Algorithm Names .......................17
   5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮アルゴリズム名 .......................17
   5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security Considerations ........................................17
   6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュリティの考察 ........................................17
   6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is intended only
   to create the initial state of the IANA databases for the SSH
   protocol and also contains instructions for future assignments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHプロトコルについてのIANAのデータベースの初期状態を作ることだけが目的だ. また, 将来の割り当てについての指示も含んでいる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Except for one HISTORIC algorithm generally regarded as obsolete,
   this document does not define any new protocols or number ranges not
   already defined in: [SSH-ARCH], [SSH-TRANS], [SSH-USERAUTH],
   [SSH-CONNECT].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般に時代遅れとみなされている1つの歴史的なアルゴリズムを除いて, この文書は,[SSH-ARCH], [SSH-TRANS], [SSH-USERAUTH], [SSH-CONNECT] で定義されていない新しいプロトコルや番号の範囲を定義していない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This entire document is the IANA considerations for the SSH protocol,
   as defined in [SSH-ARCH], [SSH-TRANS], [SSH-USERAUTH], [SSH-CONNECT].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書全体が,[SSH-ARCH], [SSH-TRANS], [SSH-USERAUTH], [SSH-CONNECT]で定義されているSSHプロトコルに対するIANAの考慮だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This section contains conventions used in naming the namespaces, the
   initial state of the registry, and instructions for future
   assignments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この節は, 名前空間を命名規約や, レジストリの初期状態, 将来の割り当てに対する指示を含んでいる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Message Number is a byte value that describes the payload of a
   packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージ番号は, パケットのペイロードを示すbyteの値だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
   numbers are allocated as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この番号は次のように割当てられる:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1 to 19    Transport layer generic (e.g., disconnect, ignore,
                   debug, etc.)
        20 to 29   Algorithm negotiation
        30 to 49   Key exchange method specific (numbers can be reused
                   for different authentication methods)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1 to 19    トランスポート層一般(例: 切断, 無視, デバッグなど
      20 to 29   アルゴリズムのネゴシエーション
      30 to 49   鍵交換方式ごとに特有(番号は, 異なる方式で再利用されてもよい)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>50 to 59   User authentication generic
        60 to 79   User authentication method specific (numbers can be
                   reused for different authentication methods)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>50 to 59   ユーザ認証一般
      60 to 79   ユーザ認証法ごとに特有(番号は, 異なる方式で再利用されてもよい)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>80 to 89   Connection protocol generic
        90 to 127  Channel related messages</seg>
      </tuv>
      <tuv lang="JA">
        <seg>80 to 89   コネクションプロトコル一般
      90 to 127  チャンネルに関連したメッセージ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table identifies the initial assignments of the Message
   ID values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, メッセージIDの値の初期の割り当てを示す</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new message numbers in the range of 1 to
   29, 50 to 59, and 80 to 127 MUST be done through the STANDARDS ACTION
   method, as described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>1 から 29, 50 から 59, 80から 127 の範囲に新たなメッセージ番号を割り当てる要求は, [RFC2434] に記述されている STANDARDS ACTION におってされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meanings of message numbers in the range of 30 to 49 are specific
   to the key exchange method in use, and their meaning will be
   specified by the definition of that method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>30から49の範囲のメッセージ番号は, 利用する鍵交換法に特有だ. その意味は方法の定義で決まる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meanings of message numbers in the range of 60 to 79 are specific
   to the user authentication method in use, and their meaning will be
   specified by the definition of that method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>60から79の範囲のメッセージ番号は, 利用する認証法に特有だ. その意味は方法の定義で決まる.T</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new message numbers in the range of 128
   to 191 MUST be done through the IETF CONSENSUS method, as described
   in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>128から191の範囲に新たなメッセージ番号を割り当てる要求は, [RFC2434] に記述されている IETF CONSENSUS によってされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IANA will not control the message numbers in the range of 192
   through 255.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANAは, 192 から 255 の範囲のメッセージ番号は制御しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   associated Disconnection Message 'description' is a human-readable
   message that describes the disconnect reason.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連する切断メッセージの 'description' は, 切断の理由を示す人間が解読できるメッセージだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol packets containing the SSH_MSG_DISCONNECT message MUST have
   Disconnection Message 'reason code' values in the range of 0x00000001
   to 0xFFFFFFFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_DISCONNECT メッセージを含むプロトコルのパケットは, 0x00000001 から 0xFFFFFFFF の範囲の切断メッセージの 'reason code' を持たなければならない..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table identifies the initial assignments of the
   SSH_MSG_DISCONNECT 'description' and 'reason code' values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, SSH_MSG_DISCONNECT の 'description' と 'reason code' の値の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symbolic Name                                  reason code
         -------------                                  -----------
         SSH_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT          1
         SSH_DISCONNECT_PROTOCOL_ERROR                       2
         SSH_DISCONNECT_KEY_EXCHANGE_FAILED                  3
         SSH_DISCONNECT_RESERVED                             4
         SSH_DISCONNECT_MAC_ERROR                            5
         SSH_DISCONNECT_COMPRESSION_ERROR                    6
         SSH_DISCONNECT_SERVICE_NOT_AVAILABLE                7
         SSH_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED       8
         SSH_DISCONNECT_HOST_KEY_NOT_VERIFIABLE              9
         SSH_DISCONNECT_CONNECTION_LOST                     10
         SSH_DISCONNECT_BY_APPLICATION                      11
         SSH_DISCONNECT_TOO_MANY_CONNECTIONS                12
         SSH_DISCONNECT_AUTH_CANCELLED_BY_USER              13
         SSH_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE      14
         SSH_DISCONNECT_ILLEGAL_USER_NAME                   15</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シンボル名                                    reason code
         -------------                                  -----------
         SSH_DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT          1
         SSH_DISCONNECT_PROTOCOL_ERROR                       2
         SSH_DISCONNECT_KEY_EXCHANGE_FAILED                  3
         SSH_DISCONNECT_RESERVED                             4
         SSH_DISCONNECT_MAC_ERROR                            5
         SSH_DISCONNECT_COMPRESSION_ERROR                    6
         SSH_DISCONNECT_SERVICE_NOT_AVAILABLE                7
         SSH_DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED       8
         SSH_DISCONNECT_HOST_KEY_NOT_VERIFIABLE              9
         SSH_DISCONNECT_CONNECTION_LOST                     10
         SSH_DISCONNECT_BY_APPLICATION                      11
         SSH_DISCONNECT_TOO_MANY_CONNECTIONS                12
         SSH_DISCONNECT_AUTH_CANCELLED_BY_USER              13
         SSH_DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE      14
         SSH_DISCONNECT_ILLEGAL_USER_NAME                   15</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disconnection Message 'reason code' values MUST be assigned
   sequentially.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切断メッセージの 'reason code' の値は, 連続して割り当てられなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new Disconnection Message
   'reason code' values, and their associated Disconnection Message
   'description' text, in the range of 0x00000010 through 0xFDFFFFFF,
   MUST be done through the IETF CONSENSUS method, as described in
   [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい切断メッセージの 'reason code' の値と関連する切断メッセージの 'description' を割り当てる要求は, 0x00000010 から 0xFDFFFFFF の範囲については [RFC2434] に記述されている IETF CONSENSUS におってされなければならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IANA will not assign Disconnection Message 'reason
   code' values in the range of 0xFE000000 through 0xFFFFFFFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANAは, 0xFE000000 から 0xFFFFFFFF の範囲の 切断メッセージの'reason code' の値は割り当てない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disconnection Message 'reason code' values in that range are left for
   PRIVATE USE, as described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>その範囲の切断メッセージの 'reason code'の値は, やはり [RFC2434]に記述されている プライベートな利用 (PRIVATE USE) に予約されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   associated Channel Connection Failure 'description' text is a human-
   readable message that describes the channel connection failure
   reason.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連するチャンネル接続失敗の 'description' は, チャンネル接続失敗の理由を示す人間が解読できるメッセージだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol packets containing the SSH_MSG_CHANNEL_OPEN_FAILURE message
   MUST have Channel Connection Failure 'reason code' values in the
   range of 0x00000001 to 0xFFFFFFFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_CHANNEL_OPEN_FAILURE メッセージを含むプロトコルのパケットは, 0x00000001 から 0xFFFFFFFF の範囲のチャンネル接続失敗の 'reason code' を持たなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial assignments for the 'reason code' values and
   'description' values are given in the table below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'reason code' の値と 'description' の値の初期の割り当ては, 次の表で示されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the
   values for the 'reason code' are given in decimal format for
   readability, but they are actually uint32 values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'reason code' は読み易いように10進のフォーマットで書かれているが, 実際にはuint32の値であることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symbolic Name                                  reason code
         -------------                                  -----------
         SSH_OPEN_ADMINISTRATIVELY_PROHIBITED                1
         SSH_OPEN_CONNECT_FAILED                             2
         SSH_OPEN_UNKNOWN_CHANNEL_TYPE                       3
         SSH_OPEN_RESOURCE_SHORTAGE                          4</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シンボル名                                    reason code
         -------------                                  -----------
         SSH_OPEN_ADMINISTRATIVELY_PROHIBITED                1
         SSH_OPEN_CONNECT_FAILED                             2
         SSH_OPEN_UNKNOWN_CHANNEL_TYPE                       3
         SSH_OPEN_RESOURCE_SHORTAGE                          4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Channel Connection Failure 'reason code' values MUST be assigned
   sequentially.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネル接続失敗の 'reason code' の値は, 連続して割り当てられなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new Channel Connection
   Failure 'reason code' values, and their associated Channel Connection
   Failure 'description string', in the range of 0x00000005 to
   0xFDFFFFFF MUST be done through the IETF CONSENSUS method, as
   described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネル接続失敗の 'reason code' の値と関連するチャンネル接続失敗の 'description' を割り当てる要求は, 0x00000010 から 0xFDFFFFFF の範囲については [RFC2434] に記述されている IETF CONSENSUS によってされなければならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Failure 'reason code' values in the range of 0xFE000000 to
   0xFFFFFFFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Channel Connection Failure 'reason code' values in that
   range are left for PRIVATE USE, as described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この範囲のチャンネル接続失敗の 'reason code'の値は, [RFC2434]に記述されている プライベートな利用 (PRIVATE USE) に予約されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While it is understood that the IANA will have no control over the
   range of 0xFE000000 to 0xFFFFFFFF, this range will be split in two
   parts and administered by the following conventions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0xFE000000 to 0xFFFFFFFF の範囲についてはIANAはなんの制御もしないが, この範囲は次の規約に従って2つの部分に分割されて管理される. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The range of 0xFE000000 to 0xFEFFFFFF is to be used in conjunction
      with locally assigned channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  0xFE000000 から 0xFEFFFFFF の範囲は, ローカルに割り当てられたチャンネルと共に利用されるためにある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if a channel is
      proposed with a 'channel type' of &quot;example_session@example.com&quot;
      but fails, then the server will respond with either a 'reason
      code' assigned by the IANA (as listed above and in the range of
      0x00000001 to 0xFDFFFFFF), or with a locally assigned value in the
      range of 0xFE000000 to 0xFEFFFFFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば,&quot;example_session@example.com&quot; という 'channel type' のチャンネルが提案されたが失敗したとき, サーバは(前述ないし0x00000001 から 0xFDFFFFFFの範囲の) IANA で割り当てられた 'reason code'を返すか,  0xFE000000 から 0xFEFFFFFF の埴のローカルに割り当てられた値を'reason code' を返す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, if the server does
      not understand the proposed 'channel type', even if it is a
      locally defined 'channel type', then the 'reason code' MUST be
      0x00000003, as described above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もちろん, サーバが提案された 'channel type' を理解できない場合は, それがローカルに定義された 'channel type' であっても, 'reason code' は 前述した0x00000003 でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server does understand the
      'channel type', but the channel still fails to open, then the
      server SHOULD respond with a locally assigned 'reason code' value
      that is consistent with the proposed local 'channel type'.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバが 'channel type' を理解するがチャンネルの開始に失敗するなら, サーバは提案されたローカルな 'channel type' に対応するローカルに割り当てられた値を返す必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is
      assumed that practitioners will first attempt to use the IANA-
      assigned 'reason code' values and then document their locally
      assigned 'reason code' values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行する者が, まずIANAで割り当てられた 'reason code' を利用しようとし, その次にローカルに割り当てられた 'reason code' を利用しようとすることを前提としている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  There are no restrictions or suggestions for the range starting
      with 0xFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  0xFFで始まる範囲については, 制限や示唆はない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No interoperability is expected for anything used in
      this range.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この範囲を利用する際は, 相互運用性は期待されない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Extended Channel Data Transfer 'data_type_code' is a uint32
   value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張チャンネルデータ転送の 'data_type_code' は uint32の値だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The associated Extended Channel Data Transfer 'data' is a
   human-readable message that describes the type of data allowed to be
   transferred in the channel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>関連する拡張チャンネルデータ転送の 'data' は, チャンネルで転送されるデータの種類を示した人間が解読できるメッセージだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol packets containing the SSH_MSG_CHANNEL_EXTENDED_DATA message
   MUST have Extended Channel Data Transfer 'data_type_code' values in
   the range of 0x00000001 to 0xFFFFFFFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> SSH_MSG_CHANNEL_EXTENDED_DATA メッセージを含むプロトコルのパケットは, 0x00000001 から 0xFFFFFFFF の範囲の拡張チャンネルデータ転送の 'data_type_code' を持たなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is described in
   [SSH-CONNECT].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, [SSH-CONNECT] で記述されている. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial assignments for the 'data_type_code' values and 'data'
   values are given in the table below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'data_type_code' と ''data' の初期の割り当ては, 以下に示す表で与えられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value for the
   'data_type_code' is given in decimal format for readability, but the
   values are actually uint32 values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'data_type_code' は読み易いように10進のフォーマットで書かれているが, 実際にはuint32の値であることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Symbolic name                        data_type_code
         -------------                        --------------
         SSH_EXTENDED_DATA_STDERR                   1</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シンボル名                             data_type_code
         -------------                        --------------
         SSH_EXTENDED_DATA_STDERR                   1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended Channel Data Transfer 'data_type_code' values MUST be
   assigned sequentially.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張チャンネルデータ転送の 'data_type_code' の値は, 連続して割り当てられなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new Extended
   Channel Data Transfer 'data_type_code' values, and their associated
   Extended Channel Data Transfer 'data' strings, in the range of
   0x00000002 to 0xFDFFFFFF, MUST be done through the IETF CONSENSUS
   method, as described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張チャンネルデータ転送の 'data_type_code' の値と関連する拡張チャンネルデータ転送の 'data' を割り当てる要求は, 0x00000002 から 0xFDFFFFFF の範囲については [RFC2434] に記述されている IETF CONSENSUS によってされなければならない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IANA will not assign Extended
   Channel Data Transfer 'data_type_code' values in the range of
   0xFE000000 to 0xFFFFFFFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANAは, 0xFE000000 から 0xFFFFFFFF の範囲の 拡張チャンネルデータ転送の 'data_type_code' の値は割り当てない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extended Channel Data Transfer
   'data_type_code' values in that range are left for PRIVATE USE, as
   described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この範囲の拡張チャンネルデータ転送の 'data_type_code'の値は,  [RFC2434]に記述されている プライベートな利用 (PRIVATE USE) に予約されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH_MSG_CHANNEL_REQUEST messages with a &quot;pty-req&quot; string MUST contain
   'encoded terminal modes'.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;ptr-req&quot; string を含む SSH_MSG_CHANNEL_REQUEST メッセージは,  'encoded terminal modes' を含まなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'encoded terminal modes' value is a
   byte stream of opcode-argument pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'encoded terminal modes' の値は, オペコード-引数のペアのバイトストリームだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol packets containing the SSH_MSG_CHANNEL_REQUEST message with
   a &quot;pty-req&quot; string MUST contain an 'encoded terminal modes' value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;ptr-req&quot; string を含む SSH_MSG_CHANNEL_REQUEST メッセージを含むプロトコルのパケットは, &quot;ptr-req&quot; string を含む SSH_MSG_CHANNEL_REQUEST メッセージは,  'encoded terminal modes' の値を含まなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The opcode values consist of a single byte and are in the range of 1
   to 255.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オペコードの値は, 1から255の範囲の単一の byte からなる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Opcodes 160 to 255
   are not yet defined.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>160 から 255 のオペコードはまだ定義されていない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table identifies the initial assignments of the opcode
   values that are used in the 'encoded terminal modes' value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, 'encoded terminal modes' の値に使われるオペコードの値の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>opcode  mnemonic       description
         ------  --------       -----------
         0     TTY_OP_END  Indicates end of options.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>オペコード  mnemonic       説明
         ------  --------       -----------
         0     TTY_OP_END  オプションの終りを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly
                            for the other characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>他の文字についても同様.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not all of these
                            characters are supported on all systems.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの文字すべてが, すべてのシステムでサポートされているわけではない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2     VQUIT       The quit character (sends SIGQUIT signal on
                            POSIX systems).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2     VQUIT       終了文字(POSIX シテムでは, SIGQUITを送る).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5     VEOF        End-of-file character (sends EOF from the
                            terminal).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>5     VEOF        End-of-file 文字 (ターミナルからEOFを送る).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6     VEOL        End-of-line character in addition to
                            carriage return and/or linefeed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>6     VEOL        キャリッジリターンと/もしくはラインフィードに追加される End-of-line 文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8     VSTART      Continues paused output (normally
                            control-Q).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>8     VSTART      中断した出力を再開する(通常は control-Q).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>14    VLNEXT      Enter the next character typed literally,
                            even if it is a special character
         15    VFLUSH      Character to flush output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>14    VLNEXT      次に入力される文字が特別な文字だったとしてもその通りに入力する.
         15    VFLUSH      出力を flush する文字</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>17    VSTATUS     Prints system status line (load, command,
                            pid, etc).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>17    VSTATUS     システムのステータス行(負荷, コマンド, pidなど)を表示する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameter
                            SHOULD be 0 if this flag is FALSE,
                            and 1 if it is TRUE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>FALSEならパラメータを0に, TRUE なら 1 にする必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>37    IUCLC       Translate uppercase characters to
                            lowercase.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>37    IUCLC       大文字を小文字に変換する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>52    XCASE       Enable input and output of uppercase
                            characters by preceding their lowercase
                            equivalents with &quot;\&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>52    XCASE       (訳注: 小文字のみ有効な場合に)小文字の前に &quot;\&quot; を付けることで大文字の入出力を有効にする.Enable input and output of uppercase
                            characters by preceding their lowercase
                            equivalents with &quot;\&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>73    OCRNL       Translate carriage return to newline
                            (output).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>73    OCRNL       出力で, CRをNLに置き換える.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>74    ONOCR       Translate newline to carriage
                            return-newline (output).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>74    ONOCR       出力で, NLをCR-NLに置き換える.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>75    ONLRET      Newline performs a carriage return
                            (output).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>75    ONLRET      出力で, NLがCRを実行する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>128 TTY_OP_ISPEED  Specifies the input baud rate in
                             bits per second.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>128 TTY_OP_ISPEED  bit/秒単位で入力バンドレートを指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>129 TTY_OP_OSPEED  Specifies the output baud rate in
                             bits per second.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>129 TTY_OP_OSPEED  bit/秒単位で出力バンドレートを指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new opcodes and their associated
   arguments MUST be done through the IETF CONSENSUS method, as
   described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいオペコードと関連する引数の割り当ての要求は, [RFC2434] に記述されている IETF CONSENSUS によってされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the following sections, the values for the name spaces are
   textual.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以降の節で, 名前空間に対する値をに表記する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The conventions and instructions to the IANA for future
   assignments are given in this section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この節には, 規約と, 将来の割り当てについてのIANAへの指示がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial assignments are
   given in their respective sections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>初期の割り当ては, それぞれの節で与えられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All names registered by the IANA in the following sections MUST be
   printable US-ASCII strings, and MUST NOT contain the characters at-
   sign (&quot;@&quot;), comma (&quot;,&quot;), whitespace, control characters (ASCII codes
   32 or less), or the ASCII code 127 (DEL).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以降の節のIANAによって登録されるすべての名前は, 表示可能なUS-ASCIIの文字列で,アットマーク(&quot;@&quot;), コンマ (&quot;,&quot;), スペース, 制御文字(ASCIIコード 32以下), ASCIIコードの127 (DEL)を含んではならない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names are case-sensitive,
   and MUST NOT be longer than 64 characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前は大文字小文字が区別され, 64文字以下でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IANA will
   not register, and will not control, names with the at-sign in them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANAは,  アットマークを含む名前を登録しないし管理しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names with the at-sign in them will have the format of
   &quot;name@domainname&quot; (without the double quotes) where the part
   preceding the at-sign is the name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アットマークを含む名前は, &quot;name@domainname&quot; (ダブルクォーテーションを除く) という形式だ. アットマークに先行する部分が(狭い意味での)名前だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format of the part preceding
   the at-sign is not specified; however, these names MUST be printable
   US-ASCII strings, and MUST NOT contain the comma character (&quot;,&quot;),
   whitespace, control characters (ASCII codes 32 or less), or the ASCII
   code 127 (DEL).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アットマークの前の部分の形式は指定されていない; しかし, 表示可能な US-ASCIIの文字列で, コンマ (&quot;,&quot;), スペース, 制御文字(ASCIIコード 32以下), ASCIIコードの127 (DEL)を含んではならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   part following the at-sign MUST be a valid, fully qualified internet
   domain name [RFC1034] controlled by the person or organization
   defining the name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アットマークに続く部分は, 名前を定義する個人ないし組織で管理されている有効な完全に記述したドメイン名 [RFC1034]でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names are case-sensitive, and MUST NOT be longer
   than 64 characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前は大文字小文字が区別され, 64文字以下でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is up to each domain how it manages its local
   namespace.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルな名前空間をどう管理するかは, それぞれのドメイン次第だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has been noted that these names resemble STD 11
   [RFC0822] email addresses.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この名前が, STD 11 [RFC0822]のメールアドレスと似ていることを明記しておく.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is purely coincidental and has
   nothing to do with STD 11 [RFC0822].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, 単なる偶然でありSTD 11 [RFC0822]とは関係ない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example of a locally defined
   name is &quot;ourcipher-cbc@example.com&quot; (without the double quotes).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルに定義される名前の例の1つは, &quot;ourcipher-cbc@example.com&quot; (ダブルクォーテーションを除く) だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new names MUST be done through the IETF
   CONSENSUS method, as described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい名前の割り当ての要求は, [RFC2434] に記述されている IETF CONSENSUS によってされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   following table lists the initial assignments of the 'service name'
   values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, service_name の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Authentication Method Name is used to describe an authentication
   method for the &quot;ssh-userauth&quot; service [SSH-USERAUTH].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証法の名前は, &quot;ssh-userauth&quot; サービス [SSH-USERAUTH] の認証法を記述するのに使われる. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following
   table identifies the initial assignments of the Authentication Method
   Names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, 認証法の名前の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table lists the initial assignments to the Connection
   Protocol Type and Request names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, コネクションプロトコルのタイプとリクエスト名の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table lists the initial assignments of the Connection
   Protocol Channel Types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, コネクションプロトコルのチャンネルのタイプの初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table lists the initial assignments of the Connection
   Protocol Global Request Names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, コネクションプロトコルのグローバルなリクエスト名の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table lists the initial assignments of the Connection
   Protocol Channel Request Names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, コネクションプロトコルのチャンネルのリクエスト名の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table lists the initial assignments of the Signal
   Names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, シグナル名の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are no initial assignments of the Connection Protocol Subsystem
   Names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>コネクションプロトコルのサブシステムの名前には初期の割り当てはない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The name &quot;diffie-hellman-group1-sha1&quot; is used for a key exchange
   method using an Oakley group, as defined in [RFC2409].</seg>
      </tuv>
      <tuv lang="JA">
        <seg> 名前 &quot;diffie-hellman-group1-sha1&quot; は, [RFC2409]で定義されている Oakley群を用いる鍵交換法のために用いられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH maintains
   its own group identifier space, which is logically distinct from
   Oakley [RFC2412] and IKE; however, for one additional group, the
   Working Group adopted the number assigned by [RFC3526], using
   &quot;diffie-hellman-group14-sha1&quot; for the name of the second defined
   group.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHは, Oakley [RFC2412] や IKE と論理的に異なる, 自身の群識別子を維持している. しかし, 追加の群として, ワーキンググループは[RFC3526] で割当てられた数を採用した. この2つ目の群の名前として, &quot;diffie-hellman-group14-sha1&quot; を用いる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations should treat these names as opaque
   identifiers and should not assume any relationship between the groups
   used by SSH and the groups defined for IKE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は, これらの名前を内部識別子として扱わなければならない. また, SSHが用いる群とIKEで定義された群との間の関係を仮定してはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table identifies the initial assignments of the key
   exchange methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, 鍵交換法の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table identifies the initial assignment of the
   Encryption Algorithm Names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, 暗号アルゴリズムの名前の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption Algorithm Name                   Reference
         -------------------------                   ---------
         3des-cbc                           [SSH-TRANS, Section 6.3]
         blowfish-cbc                       [SSH-TRANS, Section 6.3]
         twofish256-cbc                     [SSH-TRANS, Section 6.3]
         twofish-cbc                        [SSH-TRANS, Section 6.3]
         twofish192-cbc                     [SSH-TRANS, Section 6.3]
         twofish128-cbc                     [SSH-TRANS, Section 6.3]
         aes256-cbc                         [SSH-TRANS, Section 6.3]
         aes192-cbc                         [SSH-TRANS, Section 6.3]
         aes128-cbc                         [SSH-TRANS, Section 6.3]
         serpent256-cbc                     [SSH-TRANS, Section 6.3]
         serpent192-cbc                     [SSH-TRANS, Section 6.3]
         serpent128-cbc                     [SSH-TRANS, Section 6.3]
         arcfour                            [SSH-TRANS, Section 6.3]
         idea-cbc                           [SSH-TRANS, Section 6.3]
         cast128-cbc                        [SSH-TRANS, Section 6.3]
         none                               [SSH-TRANS, Section 6.3]
         des-cbc                            [FIPS-46-3] HISTORIC; See
                                              page 4 of [FIPS-46-3]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号アロゴリズム名                     Reference
         -------------------------                   ---------
         3des-cbc                           [SSH-TRANS, Section 6.3]
         blowfish-cbc                       [SSH-TRANS, Section 6.3]
         twofish256-cbc                     [SSH-TRANS, Section 6.3]
         twofish-cbc                        [SSH-TRANS, Section 6.3]
         twofish192-cbc                     [SSH-TRANS, Section 6.3]
         twofish128-cbc                     [SSH-TRANS, Section 6.3]
         aes256-cbc                         [SSH-TRANS, Section 6.3]
         aes192-cbc                         [SSH-TRANS, Section 6.3]
         aes128-cbc                         [SSH-TRANS, Section 6.3]
         serpent256-cbc                     [SSH-TRANS, Section 6.3]
         serpent192-cbc                     [SSH-TRANS, Section 6.3]
         serpent128-cbc                     [SSH-TRANS, Section 6.3]
         arcfour                            [SSH-TRANS, Section 6.3]
         idea-cbc                           [SSH-TRANS, Section 6.3]
         cast128-cbc                        [SSH-TRANS, Section 6.3]
         none                               [SSH-TRANS, Section 6.3]
         des-cbc                            [FIPS-46-3] HISTORIC; See
                                              page 4 of [FIPS-46-3]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table identifies the initial assignments of the MAC
   Algorithm Names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, MACアルゴリズムの名前の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>MAC Algorithm Name                      Reference
         ------------------                      ---------
         hmac-sha1                         [SSH-TRANS, Section 6.4]
         hmac-sha1-96                      [SSH-TRANS, Section 6.4]
         hmac-md5                          [SSH-TRANS, Section 6.4]
         hmac-md5-96                       [SSH-TRANS, Section 6.4]
         none                              [SSH-TRANS, Section 6.4]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MAC アルゴリズム名                      Reference
         ------------------                      ---------
         hmac-sha1                         [SSH-TRANS, Section 6.4]
         hmac-sha1-96                      [SSH-TRANS, Section 6.4]
         hmac-md5                          [SSH-TRANS, Section 6.4]
         hmac-md5-96                       [SSH-TRANS, Section 6.4]
         none                              [SSH-TRANS, Section 6.4]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table identifies the initial assignments of the Public
   Key Algorithm names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, 公開鍵アルゴリズムの名前の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public Key Algorithm Name                 Reference
         -------------------------                 ---------
         ssh-dss                            [SSH-TRANS, Section 6.6]
         ssh-rsa                            [SSH-TRANS, Section 6.6]
         pgp-sign-rsa                       [SSH-TRANS, Section 6.6]
         pgp-sign-dss                       [SSH-TRANS, Section 6.6]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵アルゴリズム名                  Reference
         -------------------------                 ---------
         ssh-dss                            [SSH-TRANS, Section 6.6]
         ssh-rsa                            [SSH-TRANS, Section 6.6]
         pgp-sign-rsa                       [SSH-TRANS, Section 6.6]
         pgp-sign-dss                       [SSH-TRANS, Section 6.6]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following table identifies the initial assignments of the
   Compression Algorithm names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の表で, 圧縮アルゴリズムの名前の初期の割り当てを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compression Algorithm Name                Reference
         --------------------------                ---------
         none                               [SSH-TRANS, Section 6.2]
         zlib                               [SSH-TRANS, Section 6.2]</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮アルゴリズム名                Reference
         --------------------------                ---------
         none                               [SSH-TRANS, Section 6.2]
         zlib                               [SSH-TRANS, Section 6.2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol provides a secure encrypted channel over an insecure
   network.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, 安全でないネットワーク上で安全な暗号化されたチャンネルを提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Full security considerations for this protocol are provided in
   [SSH-ARCH].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプトトコルのセキュリティについての考慮のすべては, [SSH-ARCH]で提供されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Secure Shell Protocol (SSH) is a protocol for secure remote login
   and other secure network services over an insecure network.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュア シェル (SSH) プロトコルは, 安全ではないネットワーク上での安全なリモートログインや他の安全なネットワークサービスのためのプロトコルだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
   document describes the SSH authentication protocol framework and
   public key, password, and host-based client authentication methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, SSH認証プロトコルのフレームワークと, 公開鍵, パスワード, ホストベース認証法について記述する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional authentication methods are described in separate
   documents.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加の認証法は別のドキュメントに記述される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SSH authentication protocol runs on top of the SSH
   transport layer protocol and provides a single authenticated tunnel
   for the SSH connection protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH認証プロトコルは, SSHトランスポート層プロトコルの上で動作し, SSHコネクションプロトコルのための単一の認証されたトンネルを提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Authentication Protocol Framework ...........................4
   5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> 認証プロトコルのフレームワーク...........................4
   5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Requests .........................................4
      5.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証の要求......................................4
      5.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Responses to Authentication Requests .......................5
      5.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証の要求に対する返答.......................5
      5.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;none&quot; Authentication Request ..........................7
      5.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;none&quot; 認証要求 ..........................7
      5.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Completion of User Authentication ..........................7
      5.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザ認証の完了 ..........................7
      5.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Banner Message .............................................7
   6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>バナー メッセージ.......................................7
   6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication Protocol Message Numbers .........................8
   7.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証プロトコルのメッセージ番号.........................8
   7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public Key Authentication Method: &quot;publickey&quot; ...................8
   8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵認証法: &quot;publickey&quot; ...................8
   8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Password Authentication Method: &quot;password&quot; .....................10
   9.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスワード認証法: &quot;password&quot; .....................10
   9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Host-Based Authentication: &quot;hostbased&quot; .........................12
   10.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホストベース認証: &quot;hostbased&quot;........................12
   10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IANA Considerations ...........................................14
   11.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANA の考慮 ..............................................14
   11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security Considerations .......................................14
   12.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュリティの考察.......................................14
   12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SSH authentication protocol is a general-purpose user
   authentication protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH 認証プロトコルは, 汎用のユーザ認証プロトコルだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is intended to be run over the SSH
   transport layer protocol [SSH-TRANS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH トランスポート層プロトコル [SSH-TRANS] の上で動作することを想定している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol assumes that the
   underlying protocols provide integrity and confidentiality
   protection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, その下層のプロトコルが完全性と機密性を提供することを前提とする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document should be read only after reading the SSH architecture
   document [SSH-ARCH].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, SSHアーキテクチャ文書 [SSH-ARCH]を読んだあとに読むべきだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document freely uses terminology and
   notation from the architecture document without reference or further
   explanation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, 参照や説明なしにアーキテクチャ文書から用語や表記法を自由に利用する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this protocol starts, it receives the session identifier from
   the lower-level protocol (this is the exchange hash H from the first
   key exchange).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルが開始すると, プロトコルは下層のプロトコルからセッション識別子(最初の鍵交換の再の交換ハッシュ H)を受け取る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The session identifier uniquely identifies this
   session and is suitable for signing in order to prove ownership of a
   private key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッション識別子はユニークにセッションを識別する. これは, 公開鍵の持ち主を証明するための署名に利用するのに適当だ. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol also needs to know whether the lower-
   level protocol provides confidentiality protection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルは, 下層のプロトコルが機密性の保護を提供するかどうかを知る必要もある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server drives the authentication by telling the client which
   authentication methods can be used to continue the exchange at any
   given time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, やりとりを続けるためにその時点でどの認証法が利用できるかクライアントに伝えることで認証を始める.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client has the freedom to try the methods listed by
   the server in any order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, サーバによって示された方法をどの順番で試しても構わない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives the server complete control over
   the authentication process if desired, but also gives enough
   flexibility for the client to use the methods it supports or that are
   most convenient for the user, when multiple methods are offered by
   the server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, サーバが, もし望むならば, 認証のプロセスを完全に制御できることを意味する. 一方で, サーバから複数の方法が提供された場合に, クライアントがサポートしていたりユーザにもっとも便利な認証法を利用可能な自由度も提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication methods are identified by their name, as defined in
   [SSH-ARCH].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証法は, [SSH-ARCH]で定義されているように, その名前で識別される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;none&quot; method is reserved, and MUST NOT be listed as
   supported.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;none&quot; は予約されている. しかし, サポートしている認証法として示してはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server MUST
   always reject this request, unless the client is to be granted access
   without any authentication, in which case, the server MUST accept
   this request.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, この要求を常に拒否しなければならない. ただし, クライアントが認証なしで正当なアクセスができる場合に限っては, サーバはこの要求を受け入れなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The main purpose of sending this request is to get the
   list of supported methods from the server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この要求を送る主要な目的は, サーバからサポートしている認証法のリストを得ることだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server SHOULD have a timeout for authentication and disconnect if
   the authentication has not been accepted within the timeout period.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーアは, 認証のタイムアウト期間を持つ必要がある. また, そのタイムアウト期間内に認証が受け入れられなかった場合に切断する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additionally, the
   implementation SHOULD limit the number of failed authentication
   attempts a client may perform in a single session (the RECOMMENDED
   limit is 20 attempts).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>加えて, 実装はクライアントが1つのセッションで実行できる認証の失敗の数を制限する必要がある. (20回の試行を推奨の制限とする)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the threshold is exceeded, the server
   SHOULD disconnect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この閾値を越えた場合, サーバは切断する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional thoughts about authentication timeouts and retries may be
   found in [ssh-1.2.30].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証のタイムアウトと再試行についてのさらなる考察が [ssh-1.2.30] にある..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the first few fields are defined; the remaining fields depend on
   the authentication method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のいくつかのフィールドだけが定義されている; 残りのフィールドは認証法に依存する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'user name' and 'service name' are repeated in every new
   authentication attempt, and MAY change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'user name' と 'service name' は, すべての新しい認証の試行のたびに繰り替えされる. もしくは, 変更されることもある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server implementation
   MUST carefully check them in every message, and MUST flush any
   accumulated authentication states if they change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバの実装は, すべてのメッセージを注意深く検査しなければならない. もし変更されていたら蓄積した認証の状態を消去しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>flush an authentication state, it MUST disconnect if the 'user name'
   or 'service name' changes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証の状態を消去できない場合に, 'user_name' か 'service_name' が変更されたらサーバの実装は切断しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'service name' specifies the service to start after
   authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'service name' は, 認証後に開始するサービスを指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There may be several different authenticated
   services provided.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>いくつかの異なる認証されたサービスが提供されることがある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the requested service is not available, the
   server MAY disconnect immediately or at any later time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要求されたサービスが利用可能ではない場合, サーバはすぐに切断してもよいし後のいかなる時に切断してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sending a
   proper disconnect message is RECOMMENDED.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>正当な切断メッセージを送ることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, if the
   service does not exist, authentication MUST NOT be accepted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらにせよ, サービスが存在しないなら, 認証を受け入れてはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the requested 'user name' does not exist, the server MAY
   disconnect, or MAY send a bogus list of acceptable authentication
   'method name' values, but never accept any.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要求された'user_name'が存在しない場合, サーバは切断してもよいし, 'method_name'の値に受け入れられる認証のニセのリスト(しかし実際には受け入れない)を送ってもよい. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This makes it possible
   for the server to avoid disclosing information on which accounts
   exist.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これによって, サーバが, アカウントが存在するかの情報を漏らすのを避けることができる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, if the 'user name' does not exist, the
   authentication request MUST NOT be accepted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらにせよ, 'user_name' が存在しないなら, 認証を受け入れてはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While there is usually little point for clients to send requests that
   the server does not list as acceptable, sending such requests is not
   an error, and the server SHOULD simply reject requests that it does
   not recognize.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントが, サーバが受け入れるリストに挙げていない要求を送るのは通常意味がないが, そのような要求を送ることはエラーではない. サーバは, そのような要求は認められないので, 単純に拒否する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An authentication request MAY result in a further exchange of
   messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証の要求は, さらにメッセージの交換を行なってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All such messages depend on the authentication 'method
   name' used, and the client MAY at any time continue with a new
   SSH_MSG_USERAUTH_REQUEST message, in which case the server MUST
   abandon the previous authentication attempt and continue with the new
   one.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなメッセージは, 利用する認証の 'method_name' に依存する. クライアントは, いつでも新しい SSH_MSG_USERAUTH_REQUEST を送ってよい. このとき, サーバは以前の認証の試行を法規し新しいもので認証を継続しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional 'method name' values may be defined as specified in
   [SSH-ARCH] and [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加の 'method_name' の値が, [SSH-ARCH] や [SSH-NUMBERS] で定義されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server rejects the authentication request, it MUST respond
   with the following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバが認証の要求を拒否するなら, 次のメッセージで返答しなければならない:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'authentications that can continue' is a comma-separated name-
   list of authentication 'method name' values that may productively
   continue the authentication dialog.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'authentications that can continue' は, 認証のやりとりを続行できる認証の 'method_name' の値のコンマ区切りのリストだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is RECOMMENDED that servers only include those 'method name'
   values in the name-list that are actually useful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, 実際に利用できる名前  'method_name' の値のみをリストに含めることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is not
   illegal to include 'method name' values that cannot be used to
   authenticate the user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, ユーザの認証に利用できない 'method_name'の値を含めることは違反ではない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Already successfully completed authentications SHOULD NOT be included
   in the name-list, unless they should be performed again for some
   reason.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すでに認証が成功しているものは, リストに含めないほうがよい. ただし, なんらかの理由でもう一度実行すべき場合は除く.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of 'partial success' MUST be TRUE if the authentication
   request to which this is a response was successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'partial success' の値は, 対応する認証の要求が成功した場合に TRUE でなければならない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It MUST be FALSE
   if the request was not successfully processed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要求が失敗した場合は, FALSE でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the server accepts authentication, it MUST respond with the
   following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバが認証を受け入れる場合, 次のメッセージで返答しなければならない;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is not sent after each step in a multi-method
   authentication sequence, but only when the authentication is
   complete.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数の方法で認証を行なう場合のそれぞれのステップで送られるのではなく, 認証が完了した場合にのみ送られることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client MAY send several authentication requests without waiting
   for responses from previous requests.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, 前の要求の応答を待つことなしに複数の認証の要求を送ってよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server MUST process each
   request completely and acknowledge any failed requests with a
   SSH_MSG_USERAUTH_FAILURE message before processing the next request.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, それぞれの要求を完全に処理しなければならない. また, 失敗した要求があった場合には, 次の要求を処理する前に SSH_MSG_USERAUTH_FAILURE メッセージで通知しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A request that requires further messages to be exchanged will be
   aborted by a subsequent request.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージの交換が何度か必要な要求は,次の要求によって中止されることがある. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client MUST NOT send a subsequent
   request if it has not received a response from the server for a
   previous request.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, 前の要求に対するサーバの応答を受け取っていなければ, 次の要求を送ってはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A SSH_MSG_USERAUTH_FAILURE message MUST NOT be
   sent for an aborted method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>中止された認証法については, SSH_MSG_USERAUTH_FAILURE メッセージを送ってはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When
   SSH_MSG_USERAUTH_SUCCESS has been sent, any further authentication
   requests received after that SHOULD be silently ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_USERAUTH_SUCCESS を送ったら, その後に受け取った認証の要求は静かに無視する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any non-authentication messages sent by the client after the request
   that resulted in SSH_MSG_USERAUTH_SUCCESS being sent MUST be passed
   to the service being run on top of this protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> SSH_MSG_USERAUTH_SUCCESS が送られた要求のあとでクライアントから送られる認証には関係のないメッセージは, このプロトコルの上で動作するサービスに渡されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such messages can
   be identified by their message numbers (see Section 6).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージは, そのメッセージ番号(6 節を参照)で識別される..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A client may request a list of authentication 'method name' values
   that may continue by using the &quot;none&quot; authentication 'method name'.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, 認証を続行する 'method_name'の値のリストに&quot;none&quot;を含めてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no authentication is needed for the user, the server MUST return
   SSH_MSG_USERAUTH_SUCCESS.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザに認証が必要なければ, サーバは, SSH_MSG_USERAUTH_SUCCESS を返さなければらなない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the server MUST return
   SSH_MSG_USERAUTH_FAILURE and MAY return with it a list of methods
   that may continue in its 'authentications that can continue' value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さもなければ, サーバは, SSH_MSG_USERAUTH_FAILURE を返さなければならない. また, サーバは, 認証を続行する 'authentications that can continue' の値のリストに &quot;none&quot; を含めてもよい. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Authentication is complete when the server has responded with
   SSH_MSG_USERAUTH_SUCCESS.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバが, SSH_MSG_USERAUTH_SUCCESS を返すと, 認証は完了する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All authentication related messages
   received after sending this message SHOULD be silently ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージが送信されたあとで受け取るすべての認証関係のメッセージは, 静かに無視される必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After sending SSH_MSG_USERAUTH_SUCCESS, the server starts the
   requested service.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, SSH_MSG_USERAUTH_SUCCESS を送ったら, 要求されたサービスを始める.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some jurisdictions, sending a warning message before
   authentication may be relevant for getting legal protection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>法的な事情によっては, 認証の前に警告メッセージを送ることで, 法律上な保護が得られる場合がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many
   UNIX machines, for example, normally display text from /etc/issue,
   use TCP wrappers, or similar software to display a banner before
   issuing a login prompt.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば, 多くのUNIXマシンは, ログインプロンプトを表示する前に, 通常 /etc/issue からのテキストを表示したり, TCP wrappers や似たソフトウェアを用いてバナーを表示する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SSH server may send an SSH_MSG_USERAUTH_BANNER message at any
   time after this authentication protocol starts and before
   authentication is successful.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHのサーバも, 認証プロトコルが開始してから認証が完了するまでのいつでも, SSH_MSG_USERAUTH_BANNER メッセージを送信できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message contains text to be
   displayed to the client user before authentication is attempted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージは, 認証が試みられる前にユーザに表示されるテキストを含んでいる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   format is as follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>形式は以下の通り:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since the 'message' is likely to be sent for every login
   attempt, and since some client software will need to open a separate
   window for this warning, the client software may allow the user to
   explicitly disable the display of banners from the server.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら, 'message' はすべてのログインの試行に対して送られるだろうし, この警告のために別のウィンドウを開く必要のあるクライアントもあるだろう. このため, クライアントのソフトウェアは, ユーザがサーバからのバナーの表示を明示的に無効できるようにしてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   'message' may consist of multiple lines, with line breaks indicated
   by CRLF pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この 'message' は複数行から構成されてもよい. 改行は CRLF のペアで示される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the 'message' string is displayed, control character filtering,
   discussed in [SSH-ARCH], SHOULD be used to avoid attacks by sending
   terminal control characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'message' 文字列を表示するなら, [SSH-ARCH]での議論のように, 端末の制御文字を利用した攻撃を避けるために制御文字のフィルタを用いる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All message numbers used by this authentication protocol are in the
   range from 50 to 79, which is part of the range reserved for
   protocols running on top of the SSH transport layer protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証プロトコルで利用されるすべてのメッセージ番号は, 50から79の範囲にある. この範囲は, SSHトランスポート層プロトコルの上で動作するプロトコルのために予約された範囲の一部だ. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message numbers of 80 and higher are reserved for protocols running
   after this authentication protocol, so receiving one of them before
   authentication is complete is an error, to which the server MUST
   respond by disconnecting, preferably with a proper disconnect message
   sent to ease troubleshooting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>80以上のメッセージ番号は, 認証プロトコルのあとで動作するプロトコルのために予約されている. 認証が完了する前にこの範囲の番号を受けとったらそれはエラーだ. サーバは, 切断を返答しなければならない. トラブルシューティングを容易にするために適切な切断メッセージをM送ることが好ましい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After successful authentication, such messages are passed to the
   higher-level service.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>認証が成功したら, これらのメッセージは高位のサービスに送られる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the above, there is a range of message numbers (60 to
   79) reserved for method-specific messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>上記に加えて, 60 から 79 までの範囲のメッセージ番号は, 認証法に依存するメッセージに予約されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These messages are only
   sent by the server (client sends only SSH_MSG_USERAUTH_REQUEST
   messages).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのメッセージはサーバからのみ送られる. (クライアントは,SSH_MSG_USERAUTH_REQUEST メッセージのみを送る.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different authentication methods reuse the same message
   numbers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なる認証法は, 同じメッセージ番号を再利用する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only REQUIRED authentication 'method name' is &quot;publickey&quot;
   authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>唯一実装を要求されている認証の 'method_name' が &quot;publickey&quot; 認証だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All implementations MUST support this method;
   however, not all users need to have public keys, and most local
   policies are not likely to require public key authentication for all
   users in the near future.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての実装は, この認証法をサポートしなければならない. しかし, すべてのユーザが公開鍵を持つ必要はない. また, 近い将来に多くのローカルなポリシーがすべてのユーザに対して公開鍵認証を要求することはないだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this method, the possession of a private key serves as
   authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この認証法では, 秘密鍵を所持によって認証を行なう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method works by sending a signature created
   with a private key of the user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザの秘密鍵で作られた署名を送ることで, この認証法は動作する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server MUST check that the key
   is a valid authenticator for the user, and MUST check that the
   signature is valid.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, 鍵がユーザの正当な認証情報かどうかをチェックしなければならない. また, 署名が正当かチェックしなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If both hold, the authentication request MUST be
   accepted; otherwise, it MUST be rejected.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以上の両方が成立したら, 認証の要求は受け入れられなければならない. さもなければ, 拒否されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the server MAY
   require additional authentications after successful authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>成功した認証のあとで, サーバは追加の認証を要求してもよいことを注記しておく.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Private keys are often stored in an encrypted form at the client
   host, and the user must supply a passphrase before the signature can
   be generated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>秘密鍵は, しばしばクライアントのホストに暗号化されて保持される. ユーザは, 署名が生成される前にパスフレーズを提供しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even if they are not, the signing operation involves
   some expensive computation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしそれがなくても, 署名の計算は多くの演算能力を必要とする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid unnecessary processing and user
   interaction, the following message is provided for querying whether
   authentication using the &quot;publickey&quot; method would be acceptable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>不必要な処理とユーザとの対話を避けるため, &quot;publickey&quot; 認証法を用いた認証が受け入れられるかどうかを尋ねるために, 以下のメッセージが提供されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public key algorithms are defined in the transport layer
   specification [SSH-TRANS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵アルゴリズムは, トランスポート層の仕様 [SSH-TRANS] で定義されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'public key blob' may contain
   certificates.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'public key blob' は, 証明書を含むかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the list is not constrained by what was negotiated
   during key exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特に, 鍵交換の際に交渉されたリストに縛られなくてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server does not support some algorithm,
   it MUST simply reject the request.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバがアルゴリズムをサポートしていなければ, 要求を単に拒否しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server MUST respond to this message with either
   SSH_MSG_USERAUTH_FAILURE or with the following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, このメッセージに対して SSH_MSG_USERAUTH_FAILURE か 次のメッセージを返さなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To perform actual authentication, the client MAY then send a
   signature generated using the private key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それから, 実際の認証を行なうために, クライアントは, 秘密鍵を用いて生成した署名を送ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client MAY send the
   signature directly without first verifying whether the key is
   acceptable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, 鍵が受け入れられるかの最初の確認なしに直接署名を送ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of 'signature' is a signature by the corresponding private
   key over the following data, in the following order:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'signature' の値は, 次の順番のデータに対する対応する秘密鍵による署名だ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the server receives this message, it MUST check whether the
   supplied key is acceptable for authentication, and if so, it MUST
   check whether the signature is correct.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバがこのメッセージを受け取ったら, 提供された鍵が認証で受け入れられるかチェックしなければならない. もしそうならば署名が正しいかチェックしなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the
   server may require additional authentications.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバが, 追加の認証法を要求してもよいことを注記しておく.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server MUST
   respond with SSH_MSG_USERAUTH_SUCCESS (if no more authentications are
   needed), or SSH_MSG_USERAUTH_FAILURE (if the request failed, or more
   authentications are needed).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, 追加の認証が必要なければ SSH_MSG_USERAUTH_SUCCESS で, 認証要求が失敗したり追加の認証が必要な場合は SSH_MSG_USERAUTH_FAILURE で応答しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following method-specific message numbers are used by the
   &quot;publickey&quot; authentication method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;publickey&quot; 認証法では, 次の認証法特有のメッセージ番号が使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a
   server MAY request that a user change the password.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバはユーザにパスワードの変更を求める要求を送ってもよいことに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All
   implementations SHOULD support password authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての実装は, パスワード認証をサポートする必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the 'plaintext password' value is encoded in ISO-10646
   UTF-8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'plaintext password' の値は, ISO-10646
   UTF-8 でエンコードされることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is up to the server how to interpret the password and
   validate it against the password database.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスワードをどう解釈しどうパスワードのデータベースに対して検証するかは, サーバに委ねられている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the client
   reads the password in some other encoding (e.g., ISO 8859-1 - ISO
   Latin1), it MUST convert the password to ISO-10646 UTF-8 before
   transmitting, and the server MUST convert the password to the
   encoding used on that system for passwords.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, クライアントが別のエンコーディング (たとえば, ISO 8859-1 - ISO Latin1)でパスワードを取得したなら, 転送前にパスワードを ISO-10646 UTF-8 に変換しなければならない. また. サーバは, システムがパスワードに利用しているエンコーディングにパスワードを変換しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>From an internationalization standpoint, it is desired that if a user
   enters their password, the authentication process will work
   regardless of what OS and client software the user is using.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>国際化の立場から, パスワード認証が行なわれるときに, ユーザの使うOSやクライアントのソフトウェアに依らずに認証が行なわれることが望ましい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Doing
   so requires normalization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このために正規化が必要だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Systems supporting non-ASCII passwords
   SHOULD always normalize passwords and user names whenever they are
   added to the database, or compared (with or without hashing) to
   existing entries in the database.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ASCII以外のパスワードをサポートするシステムは, パスワードとユーザ名をデータベースに追加したり(ハッシュしたり,もしくはせずに)データベース内のエントリと比較する際にいつでも正規化する必要がある. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH implementations that both
   store the passwords and compare them SHOULD use [RFC4013] for
   normalization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスワードを保存したり比較するSSHの実装は, 正規化に[RFC4013]を使う必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that even though the cleartext password is transmitted in the
   packet, the entire packet is encrypted by the transport layer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号化されないパスワードがパケットに含まれて転送されるが, パケット全体はトランスポート層で暗号化されることを注記しておく.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both
   the server and the client should check whether the underlying
   transport layer provides confidentiality (i.e., if encryption is
   being used).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバとクライアントは, 基盤となっているトランスポート層が機密性を提供するかどうか(すなわち, 暗号化が使われているかどうか)をチェックしなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no confidentiality is provided (&quot;none&quot; cipher),
   password authentication SHOULD be disabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>機密性が提供されない(&quot;none&quot; 暗号)場合は, パスワード認証は無効とされる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no
   confidentiality or no MAC, password change SHOULD be disabled.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>機密性やMACがない場合には, パスワードの変更は無効とされる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normally, the server responds to this message with success or
   failure.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常, サーバはこのメッセージに対して成功ないし失敗のメッセージで応答する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the password has expired, the server SHOULD
   indicate this by responding with SSH_MSG_USERAUTH_PASSWD_CHANGEREQ.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, パスワードの有効期限が切れている場合, サーバは, SSH_MSG_USERAUTH_PASSWD_CHANGEREQ を応答して期限切れを示す必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In any case, the server MUST NOT allow an expired password to be used
   for authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どんな場合でも, サーバは, 期限切れのパスワードを認証に仕様してはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, the client MAY continue with a different authentication
   method, or request a new password from the user and retry password
   authentication using the following message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このとき, クライアントは別の認証法を試してもよいしユーザに新しいパスワードを要求して次のメッセージでパスワード認証を再試行してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client MAY also send
   this message instead of the normal password authentication request
   without the server asking for it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, サーバから要求されない場合でも通常のパスワード認証の要求の代わりにこのメッセージを送ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server must reply to each request message with
   SSH_MSG_USERAUTH_SUCCESS, SSH_MSG_USERAUTH_FAILURE, or another
   SSH_MSG_USERAUTH_PASSWD_CHANGEREQ.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, それぞれの要求のメッセージに SSH_MSG_USERAUTH_SUCCESS, SSH_MSG_USERAUTH_FAILURE, もしくは SSH_MSG_USERAUTH_PASSWD_CHANGEREQ で応答しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The meaning of these is as
   follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの意味は以下の通り:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH_MSG_USERAUTH_SUCCESS - The password has been changed, and
      authentication has been successfully completed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_USERAUTH_SUCCESS - パスワードは変更された. また認証も成功し完了した.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH_MSG_USERAUTH_FAILURE with partial success - The password has
      been changed, but more authentications are needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_USERAUTH_FAILURE with partial success - パスワードは変更された. さらなる認証が必要だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH_MSG_USERAUTH_FAILURE without partial success - The password
      has not been changed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_USERAUTH_FAILURE without partial success - パスワードは変更されなかった.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either password changing was not supported,
      or the old password was bad.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスワードの変更がサポートされていないか, 古いパスワードが間違っている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if the server has already
      sent SSH_MSG_USERAUTH_PASSWD_CHANGEREQ, we know that it supports
      changing the password.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もしサーバが SSH_MSG_USERAUTH_PASSWD_CHANGEREQ を送っていたら, サーバはパスワードの変更をサポートしているとみなされることを注記しておく.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH_MSG_USERAUTH_CHANGEREQ - The password was not changed because
      the new password was not acceptable (e.g., too easy to guess).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_USERAUTH_CHANGEREQ - 新しいパスワードが受け入れられない(たとえば, 容易に推測可能)のでパスワードが変更されなかった.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following method-specific message numbers are used by the
   password authentication method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パスワード認証法では, 次の認証法特有のメッセージ番号が使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some sites wish to allow authentication based on the host that the
   user is coming from and the user name on the remote host.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ユーザがやってくるホストとリモートホストでのユーザ名をベースにした認証を行ないたいサイトもある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While this
   form of authentication is not suitable for high-security sites, it
   can be very convenient in many environments.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この認証法は, 高いセキュリティを求めるサイトには適していないが, 多くの環境で非常に便利だろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This form of
   authentication is OPTIONAL.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この認証法は選択できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used, special care SHOULD be taken
   to prevent a regular user from obtaining the private host key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この認証法が使われる場合は, 一般ユーザがホストの秘密鍵を得られないようにする特別の注意が払われる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client requests this form of authentication by sending the
   following message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, 次のメッセージを送ることでこの認証法を要求する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is similar to the UNIX &quot;rhosts&quot; and
   &quot;hosts.equiv&quot; styles of authentication, except that the identity of
   the client host is checked more rigorously.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, UNIXの &quot;rhosts&quot; と &quot;hosts.equiv&quot; スタイルの認証に似ている. ただし, クライアントホストの識別がより厳格にチェックされることが異なる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method works by having the client send a signature created with
   the private key of the client host, which the server checks with that
   host's public key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この認証法は, クライアントがクライアントホストの秘密鍵で作られた署名を送りサーバがクライアントホストの公開鍵でチェックすることで動作する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the client host's identity is established,
   authorization (but no further authentication) is performed based on
   the user names on the server and the client, and the client host
   name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一度クライアントホストの識別が確立すると, (ユーザの)承認(これ以上認証は行なわれない)は, サーバでのユーザ名とクライアントでのユーザ名, クライアントのホスト名に基づいて行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public key algorithm names for use in 'public key algorithm for host
   key' are defined in the transport layer specification [SSH-TRANS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'public key algorithm for host key'で用いられる公開鍵アルゴリズム名は, トランスポート層の仕様 [SSH-TRANS] で定義されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'public host key and certificates for client host' may include
   certificates.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'public host key and certificates for client host' は 証明書を含むかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of 'signature' is a signature with the private host key of
   the following data, in this order:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'signature' の値は, 次の順番のデータに対する秘密鍵による署名だ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server MUST verify that the host key actually belongs to the
   client host named in the message, that the given user on that host is
   allowed to log in, and that the 'signature' value is a valid
   signature on the appropriate value by the given host key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, 以下を検証しなければならない. ホスト鍵が本当にメッセージ中のクライアントホストに属している, クライアントホストのユーザがログインを許可されているか, 'siggnature' の値が, ホスト鍵に対して正当かどうか.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server
   MAY ignore the client 'user name', if it wants to authenticate only
   the client host.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントホストに対してだけ認証したい場合, サーバはクライアントの 'user name' を無視してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whenever possible, it is RECOMMENDED that the server perform
   additional checks to verify that the network address obtained from
   the (untrusted) network matches the given client host name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(信用されない)ネットワークから得られたネットワークのアドレスとクライアントのホスト名が一致するかどうかの検証を, 可能な場合いつでもサーバが追加のチェックとして行なうことが推奨される. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This
   makes exploiting compromised host keys more difficult.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, 不正なホスト鍵を利用した攻撃をより難しくする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that
   this may require special handling for connections coming through a
   firewall.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, ファイアウォール越しに来る接続には特別の扱いが必要となることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IANA considerations for the SSH
   protocol, as defined in [SSH-ARCH], [SSH-TRANS], [SSH-CONNECT], and
   this document, are detailed in [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>[SSH-ARCH],
   [SSH-TRANS],  [SSH-CONNECT] とこの文書で定義される SSH プロトコルに対する IANA の考慮は,  [SSH-NUMBERS] で詳述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It assumed that this runs over a secure transport
   layer protocol, which has already authenticated the server machine,
   established an encrypted communications channel, and computed a
   unique session identifier for this session.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルでは, すでにサーバマシンを認証し暗号化されたコミュニケーションチャンネルを確立しセンションのユニークな識別子を計算した, 安全なトランスポート層プロトコルの上で動くことを仮定した.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transport layer
   provides forward secrecy for password authentication and other
   methods that rely on secret data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トランスポート層は, パスワード認証や他の秘密の情報に依存する認証法のために前方秘密性を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Secure Shell (SSH) is a protocol for secure remote login and
   other secure network services over an insecure network.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュア シェル (SSH) プロトコルは, 安全ではないネットワーク上での安全なリモートログインや他の安全なネットワークサービスのためのプロトコルだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes the SSH transport layer protocol, which
   typically runs on top of TCP/IP.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書は, SSH トランスポート層プロトコルについて記述する. このプロトコルは, 通常は TCP/IP 上で動作する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The protocol can be used as a basis
   for a number of secure network services.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, 多くの安全なネットワークサービスのための基盤として使うことができる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides strong
   encryption, server authentication, and integrity protection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, 強力な暗号化, サーバの認証, 完全性の保護を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may
   also provide compression.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, 圧縮も提供できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key exchange method, public key algorithm, symmetric encryption
   algorithm, message authentication algorithm, and hash algorithm are
   all negotiated.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換法, 公開鍵アルゴリズム, 対称暗号アルゴリズム, メッセージ認証アルゴリズム, ハッシュアルゴリズムはすべて交渉によって決まる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document also describes the Diffie-Hellman key exchange method
   and the minimal set of algorithms that are needed to implement the
   SSH transport layer protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, この文書は, Diffie-Hellman 鍵交換法とSSHトランスポート層プロトコルの実装に必要な最低限のアルゴリズムの集合についても記述する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connection Setup ................................................4
      4.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接続のセットアップ...........................................4
      4.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use over TCP/IP ............................................4
      4.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TCP/IP上での利用.......................................4
      4.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Protocol Version Exchange ..................................4
   5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルバージョンの交換.................................4
   5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compatibility With Old SSH Versions .............................5
      5.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>古い SSH のバージョンとの互換性 .............................5
      5.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Old Client, New Server .....................................6
      5.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>古いクライアントで新しいサーバ..........................6
      5.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New Client, Old Server .....................................6
      5.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいクライアントで古いサーバ.........................6
      5.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Packet Size and Overhead ...................................6
   6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パケットのサイズとオーバーヘッド.......................6
   6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Binary Packet Protocol ..........................................7
      6.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> バイナリパケットプロトコル..................................7
      6.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Maximum Packet Length ......................................8
      6.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最大パケット長 ......................................8
      6.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compression ................................................8
      6.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮...........................................8
      6.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption .................................................9
      6.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号化...............................................9
      6.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data Integrity ............................................12
      6.5.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>データの完全性........................................12
      6.5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Exchange Methods ......................................13
      6.6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換法.....................................13
      6.6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public Key Algorithms .....................................13
   7.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>公開鍵アルゴリズム..................................13
   7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Exchange ...................................................15
      7.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換.................................................15
      7.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Algorithm Negotiation .....................................17
      7.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズムのネゴシエーション........................17
      7.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Output from Key Exchange ..................................20
      7.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換からの出力................................20
      7.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Taking Keys Into Use ......................................21
   8.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の利用...............................21
   8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Diffie-Hellman Key Exchange ....................................21
      8.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Diffie-Hellman 鍵交換..................................21
      8.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key Re-Exchange ................................................23
   10.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の再交換.............................................23
   10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Service Request ...............................................24
   11.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サービスの要求.....................................24
   11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional Messages ...........................................25
      11.1.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加のメッセージ......................................25
      11.1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disconnection Message ....................................25
      11.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切断メッセージ................................25
      11.2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ignored Data Message .....................................26
      11.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>無視データメッセージ............................26
      11.3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Debug Message ............................................26
      11.4.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> デバッグメッセージ...............................26
      11.4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reserved Messages ........................................27
   12.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>予約されたメッセージ................................27
   12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Summary of Message Numbers ....................................27
   13.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージ番号のまとめ.................................27
   13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>IANA Considerations ...........................................27
   14.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANA の考慮 ........................................27
   14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security Considerations .......................................28
   15.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セキュリティの考察......................................28
   15.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   underlying transport SHOULD protect against transmission errors, as
   such errors cause the SSH connection to terminate.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>下層にあるトランスポートは, 転送エラーに対する保護をする必要がある. そのようなエラーはSSHのコネクションを終了させる原因となる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When used over TCP/IP, the server normally listens for connections on
   port 22.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>TCP/IP上で利用する際, サーバは通常22番ポートで接続を待ち受ける.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This port number has been registered with the IANA, and has
   been officially assigned for SSH.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このポート番号は IANA によって登録されている. また, SSHに対して正式に割り当てられている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the connection has been established, both sides MUST send an
   identification string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>接続が確立したら, 両方の側が識別文字列を送らなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the protocol being defined in this set of documents is version
   2.0, the 'protoversion' MUST be &quot;2.0&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書群で定義されるプロトコルはバージョン.2.0 なので, 'protoversion'は 2.0 でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'comments' string is
   OPTIONAL.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'comments' 文字列の存在は選択できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the 'comments' string is included, a 'space' character
   (denoted above as SP, ASCII 32) MUST separate the 'softwareversion'
   and 'comments' strings.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'comments' 文字列が含まれる場合, 'space' 文字(上では SP で示した. ASCII 32) が 'softwareversion' と 'comments' を区切らなければならない..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The identification MUST be terminated by a
   single Carriage Return (CR) and a single Line Feed (LF) character
   (ASCII 13 and 10, respectively).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この識別文字列は, 単一のキャリッジリターン (CR) と単一のラインフィード （LF) (それぞれ ASCII の 13 と 10) で終了されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>compatibility with older, undocumented versions of this protocol may
   want to process the identification string without expecting the
   presence of the carriage return character for reasons described in
   Section 5 of this document.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>より古いこのプロトコルの文書化されていないバージョンとの互換性を維持したい実装者は, この文書の5節で記述する理由からキャリッジリターンが存在しなくても識別文字列の処理をしたいだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum length of the string is 255 characters, including the
   Carriage Return and Line Feed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>文字列の最大長は, 255文字だ. これには キャリッジリターンとラインフィードを含む.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The part of the identification string preceding the Carriage Return
   and Line Feed is used in the Diffie-Hellman key exchange (see Section
   8).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>キャリッジリターンとラインフィードの前の文字列の部分は, Diffie-Hellman 鍵交換に使われる(8 節を参照).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server MAY send other lines of data before sending the version
   string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, バージョン文字列の前に別のデータを何行か送ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each line SHOULD be terminated by a Carriage Return and Line
   Feed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの行は, キャリッジリターンとラインフィードで終端されている必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such lines MUST NOT begin with &quot;SSH-&quot;, and SHOULD be encoded
   in ISO-10646 UTF-8 [RFC3629] (language is not specified).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの行は, &quot;SSH-&quot; で始まってはならない. また,ISO-10646 UTF-8 [RFC3629] でエンコーングされている必要がある(言語は特定されない).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients
   MUST be able to process such lines.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, これらの行を処理できる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such lines MAY be silently
   ignored, or MAY be displayed to the client user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの行は静かに無視されてもよいし, クライアントユーザに表示されてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If they are
   displayed, control character filtering, as discussed in [SSH-ARCH],
   SHOULD be used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし表示されるなら, [SSH-ARCH] で議論されているように, 制御文字のフィルタリングが利用される必要がある. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The primary use of this feature is to allow TCP-
   wrappers to display an error message before disconnecting.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この特徴の主要な目的は, TCP-wrappers に切断の前にエラーメッセージを表示することを許すことだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both the 'protoversion' and 'softwareversion' strings MUST consist of
   printable US-ASCII characters, with the exception of whitespace
   characters and the minus sign (-).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'protoversion' と 'softwareversion' は, 空白とマイナス(-)を除く印刷可能な US-ASCII 文字で構成されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'softwareversion' string is
   primarily used to trigger compatibility extensions and to indicate
   the capabilities of an implementation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'softwareversion' は, 主に互換性のための拡張を動作させたり, 実装の能力を示すために使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'comments' string SHOULD
   contain additional information that might be useful in solving user
   problems.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'comments' は, ユーザの問題を解決するのに有用な追加の情報を含む必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This identification string does not contain the optional 'comments'
   string and is thus terminated by a CR and LF immediately after the
   'softwareversion' string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この識別文字列は, 選択可能な 'comments'を含んでいない. そのため, 'softwareversion' の直後に CR と LFで終端されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All packets following the identification string SHALL use the binary
   packet protocol, which is described in Section 6.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>識別文字列のあとのすべてのパケットは, 6節で記述する, バイナリパケットプロトコルを利用することになる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As stated earlier, the 'protoversion' specified for this protocol is
   &quot;2.0&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>前述したように, このプロトコルのために定義された 'protoversion' は &quot;2.0&quot; だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Earlier versions of this protocol have not been formally
   documented, but it is widely known that they use 'protoversion' of
   &quot;1.x&quot; (e.g., &quot;1.5&quot; or &quot;1.3&quot;).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルのより以前のバージョンについては公式に文書化されていないが, より以前のバージョンは 'protoversion' に &quot;1.x&quot; (たとえば, &quot;1.5&quot; or &quot;1.3&quot;) を利用していたことが広く知られている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the time of this writing, many
   implementations of SSH are utilizing protocol version 2.0, but it is
   known that there are still devices using the previous versions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>執筆時点では, SSHの多くの実装が プロトコルバージョン 2.0 を利用しているが, まだ以前のバージョンを利用するデバイスも存在している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>way that is compatible with the installed SSH clients and servers
   that use the older version of the protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg> </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Information in this
   section is only relevant for implementations supporting compatibility
   with SSH versions 1.x.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この節では, SSH バージョン 1.x との互換性をサポートする実装にのみ関係する情報を記述する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For those interested, the only known
   documentation of the 1.x protocol is contained in README files that
   are shipped along with the source code [ssh-1.2.30].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>興味のある者のために紹介しておくと, 1.x プロトコルについての唯一の文書は, ソースコード [ssh-1.2.30] と共にリリースされた README ファイルに含まれている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Server implementations MAY support a configurable compatibility flag
   that enables compatibility with old versions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバの実装は, 古いバージョンとの互換性を有効にする互換性についての設定フラグをサポートしてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this flag is on,
   the server SHOULD identify its 'protoversion' as &quot;1.99&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このフラグが有効ならば, サーバは 'protoversion' を &quot;1.99&quot; とする必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clients
   using protocol 2.0 MUST be able to identify this as identical to
   &quot;2.0&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコル 2.0 を用いるクライアントは, 'protoversion' を &quot;2.0&quot; とできなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this mode, the server SHOULD NOT send the Carriage Return
   character (ASCII 13) after the identification string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このモードでは, サーバは識別文字列のあとのキャリッジリターン (ASCII 13) を送らないほうがよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the compatibility mode, the server SHOULD NOT send any further
   data after sending its identification string until it has received an
   identification string from the client.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この互換モードでは, クライアントからの識別文字列を受信するまではサーバはサーバの識別文字列を送ったあとでデータを送らないほうがよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server can then determine
   whether the client is using an old protocol, and can revert to the
   old protocol if required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そしてサーバは, クライアントが古いプロトコルを利用するかどうかを決定し必要ならば古いプロトコルに戻すことができる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the compatibility mode, the server MUST
   NOT send additional data before the identification string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この互換モードでは, サーバは識別文字列の前に追加の文字列を送ってはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When compatibility with old clients is not needed, the server MAY
   send its initial key exchange data immediately after the
   identification string.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>古いクライアントとの互換性が不要なら, サーバは識別文字列の後ですぐに初期の鍵交換のデータを送ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the new client MAY immediately send additional data after its
   identification string (before receiving the server's identification
   string), the old protocol may already be corrupt when the client
   learns that the server is old.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいクライアントは, 認証文字列のあとすぐに (サーバの認証文字列を受け取る前に) 追加のデータを送ってもよいので, クライアントがサーバが古いと知るときには古いプロトコルはすでに壊れていることがある. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this happens, the client SHOULD
   close the connection to the server, and reconnect using the old
   protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このときは, クライアントはサーバとの接続を切断し古いプロトコルを利用して再接続する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some readers will worry about the increase in packet size due to new
   headers, padding, and the Message Authentication Code (MAC).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいヘッダやパディング, メッセージ認証コード(MAC)のためにパケットサイズが増大することを心配する読者もいるだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   minimum packet size is in the order of 28 bytes (depending on
   negotiated algorithms).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最小のパケットサイズは, 28 byteのオーダーだ (取り決められるアルゴリズムに依存する).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The increase is negligible for large
   packets, but very significant for one-byte packets (telnet-type
   sessions).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>大きなパケットについては, 増大は無視できる. しかし, (telnetタイプのセッションでの) 1バイトのパケットについては非常に大きい. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are, however, several factors that make this a
   non-issue in almost all cases:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, いくつかの理由によりほとんどすべての場合で重大とならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the
      increase is actually from 33 to 51 bytes (roughly).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのため, 実際の増大は, (おおまかにいって)33 byte から 51 byteになる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The minimum size of the data field of an Ethernet packet is 46
      bytes [RFC0894].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  イーサネットのパケットのデータフィールドの最小サイズは, 46 byte だ [RFC0894].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Ethernet headers are considered, the increase is less than 10
      percent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>イーサネットのヘッダも考慮すると, 増大は10%よりも少ない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  The total fraction of telnet-type data in the Internet is
      negligible, even with increased packet sizes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  インターネットでのtelnetタイプのデータの割合は無視できる. たとえ, パケットサイズが増大してもだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The only environment where the packet size increase is likely to have
   a significant effect is PPP [RFC1661] over slow modem lines (PPP
   compresses the TCP/IP headers, emphasizing the increase in packet
   size).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パケットサイズの増大で重大な影響がでる可能性のある唯一の環境は, 遅いモデム回線でのPPP [RFC1661]だ (PPP は TCP/IPのヘッダを圧縮するので, パケットサイズの増大を強調する) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, with modern modems, the time needed to transfer is
   in the order of 2 milliseconds, which is a lot faster than people can
   type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 現在のモデムは転送にかかる時間は2ミリ秒のオーダで, 人間がタイプできる速度よりもかなり早い.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To
   minimize delays in screen updates, one does not want excessively
   large packets for interactive sessions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>画面の更新の遅れを最小にするため, インタラクティブなセッションで過剰な大きなパケットは求められない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum packet size is
   negotiated separately for each channel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最大のパケットサイズはそれぞれのチャンネルで独立に取り決められる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>packet_length
         The length of the packet in bytes, not including 'mac' or the
         'packet_length' field itself.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>packet_length
         byte単位のパケットの長さ. 'mac' と 'packet_length' 自体の長さは含まない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>padding_length
         Length of 'random padding' (bytes).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>padding_length
         'random padding' の長さ (byte単位).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>payload
         The useful contents of the packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>payload
         パケットの有用な中身</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If compression has been
         negotiated, this field is compressed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮(すること)が取り決められていたなら, このフィールドは圧縮される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initially, compression
         MUST be &quot;none&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初は, 圧縮は &quot;none&quot; でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>random padding
         Arbitrary-length padding, such that the total length of
         (packet_length || padding_length || payload || random padding)
         is a multiple of the cipher block size or 8, whichever is</seg>
      </tuv>
      <tuv lang="JA">
        <seg>random padding
         任意の長さのパディング, (packet_length || padding_length || payload || random padding) の全体の長さが, 暗号のブロックサイズか8のどちらか大きいほうの倍数になるようにする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
         padding SHOULD consist of random bytes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パディングは, ランダムなbyteで構成される必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum amount of
         padding is 255 bytes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パディングの最大長は, 255 byte だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mac
         Message Authentication Code.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>mac
         メッセージ認証コード.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If message authentication has
         been negotiated, this field contains the MAC bytes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージ認証コードが取り決められていたら, このフィールドはMACを含む.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initially,
         the MAC algorithm MUST be &quot;none&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初は, MACのアルゴリズムは &quot;none&quot; でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the length of the concatenation of 'packet_length',
   'padding_length', 'payload', and 'random padding' MUST be a multiple
   of the cipher block size or 8, whichever is larger.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'packet_length', 'padding_length', 'payload', 'random padding を連結した長さが, 暗号のブロックサイズか8のどちらか大きいほうの倍数になっていなければならないことに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constraint
   MUST be enforced, even when using stream ciphers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この制限は, たとえストリーム暗号を用いる場合にも実施されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the
   'packet_length' field is also encrypted, and processing it requires
   special care when sending or receiving packets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'packet_length' フィールドも暗号化されるので, パケットを送受信する際の packet_lengthの扱いには特別な注意が必要なことに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that the
   insertion of variable amounts of 'random padding' may help thwart
   traffic analysis.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, 可変の 'random padding'の挿入がトラフィック解析の防止に役立つことに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The minimum size of a packet is 16 (or the cipher block size,
   whichever is larger) bytes (plus 'mac').</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パケットの最小サイズは, 16(ないし暗号のブロックサイズ, どちらか大きいほう) byte に 'mac' が追加されたものだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations SHOULD
   decrypt the length after receiving the first 8 (or cipher block size,
   whichever is larger) bytes of a packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は, パケットの最初の8byte(ないし暗号のブロックサイズ, どちらか大きいほう)を受信したら長さを復号する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All implementations MUST be able to process packets with an
   uncompressed payload length of 32768 bytes or less and a total packet
   size of 35000 bytes or less (including 'packet_length',
   'padding_length', 'payload', 'random padding', and 'mac').</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての実装は, 32768byte以下の非圧縮の payload を持つパケットを処理できなければならない. また, 全パケットサイズ( 'packet_length',
   'padding_length', 'payload', 'random padding', 'mac' を含む) が 35000 byte 以下のパケットを処理できなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   maximum of 35000 bytes is an arbitrarily chosen value that is larger
   than the uncompressed length noted above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最大値の 35000 byte は, 上で述べた非圧縮の長さよりも大きい任意に選ばれた値だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations SHOULD
   support longer packets, where they might be needed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は, 必要がある場合はより長いパケットをサポートする必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if
   an implementation wants to send a very large number of certificates,
   the larger packets MAY be sent if the identification string indicates
   that the other party is able to process them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例えば, ある実装が非常にたくさんの数の証明書を送りたい場合, 識別文字列によってもう一方の側もそのような証明書群の処理ができることが示されているならば, より大きなパケットが送られてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However,
   implementations SHOULD check that the packet length is reasonable in
   order for the implementation to avoid denial of service and/or buffer
   overflow attacks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 実装は, DoS攻撃やバッファオーバーフロー攻撃を避けるためにパケットの長さが合理的かチェックする必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If compression has been negotiated, the 'payload' field (and only it)
   will be compressed using the negotiated algorithm.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮が取り決められている場合は, 'payload' フィールド(のみ)は, 取り決められたアルゴリズムを用いて圧縮される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   'packet_length' field and 'mac' will be computed from the compressed
   payload.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'packet_length' と 'mac' は, 圧縮された payload から計算される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compression
   MUST be independent for each direction, and implementations MUST
   allow independent choosing of the algorithm for each direction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮は, 通信の方向それぞれで独立でなければならない. また, 実装は方向それぞれについてアルゴリズムを独立に選択できなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
   practice however, it is RECOMMENDED that the compression method be
   the same in both directions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら実際上は, どちらの方向でも同じ圧縮アルゴリズムを用いることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compression context is initialized after each key exchange, and
   is passed from one packet to the next, with only a partial flush
   being performed at the end of each packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮コンテキストは鍵交換のあとで初期化され, 1つのパケットからその次のパケットへと渡される. それぞれのパケットの終わりでは, 部分的な flush のみが行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A partial flush means
   that the current compressed block is ended and all data will be
   output.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>部分的な flush とは, 現在の圧縮ブロックが終了されてすべてのデータが出力となっているということである.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current block is not a stored block, one or more
   empty blocks are added after the current block to ensure that there
   are at least 8 bits, counting from the start of the end-of-block code
   of the current block to the end of the packet payload.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし, 現在のブロックが保存されたブロックではない場合, 現在のブロックのブロック終了コードの始まりからパケットの payload の終わりまでが少なくとも8bit単位であることを保証するために現在のブロックのあとで1つかそれ以上のブロックが追加される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional methods may be defined as specified in [SSH-ARCH] and
   [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加の方法が, [SSH-ARCH] や [SSH-NUMBERS] で定義されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An encryption algorithm and a key will be negotiated during the key
   exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号アルゴリズムと鍵は, 鍵交換の間に取り決められる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When encryption is in effect, the packet length, padding
   length, payload, and padding fields of each packet MUST be encrypted
   with the given algorithm.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号化が行なわれている場合, パケットの packet length, padding
   length, payload, padding のフィールドは, 取り決められた暗号アリゴリズムによって暗号化されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The encrypted data in all packets sent in one direction SHOULD be
   considered a single data stream.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ある通信の方向で送られるすべてのパケットの暗号化済みのデータは, 単一のデータストリームとみなされる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, initialization vectors
   SHOULD be passed from the end of one packet to the beginning of the
   next packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば, 初期化ベクトルは, パケットの最後から次のパケットの最初へと引き継がれる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All ciphers SHOULD use keys with an effective key
   length of 128 bits or more.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての暗号は, 128bit以上の有効な鍵長を持つ鍵を使う必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations MUST allow the algorithm for each direction to be
   independently selected, if multiple algorithms are allowed by local
   policy.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は, ローカルなポリシーによって複数のアルゴリズムが許可されているならば, それぞれの方向のアルゴリズムが独立に選択されることを許さなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice however, it is RECOMMENDED that the same
   algorithm be used in both directions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら実際上は, どちらの方向でも同じアルゴリズムを用いることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;3des-cbc&quot; cipher is three-key triple-DES (encrypt-decrypt-
   encrypt), where the first 8 bytes of the key are used for the first
   encryption, the next 8 bytes for the decryption, and the following 8
   bytes for the final encryption.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;3des-cbc&quot; 暗号は, 3つの鍵を用いる triple-DES (encrypt-decrypt-encrypt)で, 鍵の最初の8byteが最初の暗号化に用いられ, 次の8byteが復号に用いられ, 続く8byteが最後の暗号化に用いられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This requires 24 bytes of key data
   (of which 168 bits are actually used).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>24byteの鍵データを必要とする(このうち 168 bit が実際に用いられる).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To implement CBC mode, outer
   chaining MUST be used (i.e., there is only one initialization
   vector).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>CBCモードの実装には, outer chaining が使われなければならない(すなわち, 初期化ベクトルを1つだけ用いる).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This algorithm
   is defined in [FIPS-46-3].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このアルゴリズムは, [FIPS-46-3] で定義されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since this algorithm only has
   an effective key length of 112 bits ([SCHNEIER]), it does not meet
   the specifications that SSH encryption algorithms should use keys of
   128 bits or more.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このアルゴリズムは, 112 bitの有効な鍵長しか持たないので ([SCHNEIER]), SSH の暗号アルゴリズムは128bit以上の鍵を使うべきという仕様に合致しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, this algorithm is still REQUIRED for
   historical reasons; essentially, all known implementations at the
   time of this writing support this algorithm, and it is commonly used
   because it is the fundamental interoperable algorithm.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, このアルゴリズムは歴史的な理由により依然要求されている; 実質的な面から見て, 執筆時点でのすべての知られた実装はこのアルゴリズムを実装しており, 基本的な相互運用可能なアルゴリズムであるという理由で広く用いられているからだ. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At some
   future time, it is expected that another algorithm, one with better
   strength, will become so prevalent and ubiquitous that the use of
   &quot;3des-cbc&quot; will be deprecated by another STANDARDS ACTION.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>近い将来において, より強度の高い別のアルゴリズムが広く普及して, 別の STANDARDS ACTIONによって&quot;3des-cbc'の利用が非推奨となるだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;blowfish-cbc&quot; cipher is Blowfish in CBC mode, with 128-bit keys
   [SCHNEIER].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;blowfish-cbc&quot; 暗号は CBCモードでの Blowfish で, 128-bit の鍵を使う [SCHNEIER].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;twofish-cbc&quot; or &quot;twofish256-cbc&quot; cipher is Twofish in CBC mode,
   with 256-bit keys as described [TWOFISH].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;twofish-cbc&quot; もしくは &quot;twofish256-cbc&quot; 暗号は, CBCモードの Twofish で, 256-bitの鍵を使う. [TWOFISH] で記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a block cipher
   with 16-byte blocks.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, 16byteブロックのブロック暗号だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;twofish192-cbc&quot; cipher is the same as above, but with a 192-bit
   key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;twofish192-cbc&quot; 暗号は, 同様の暗号だが, 192-bit の鍵を使う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;twofish128-cbc&quot; cipher is the same as above, but with a 128-bit
   key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;twofish128-cbc&quot; 暗号は, 同様の暗号だが, 128-bit の鍵を使う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;aes256-cbc&quot; cipher is AES (Advanced Encryption Standard)
   [FIPS-197], in CBC mode.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;aes256-cbc&quot; 暗号は, CBCモードの AES (Advanced Encryption Standard) [FIPS-197] だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;serpent256-cbc&quot; cipher in CBC mode, with a 256-bit key as
   described in the Serpent AES submission.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;serpent256-cbc&quot; 暗号は, CBCモードで 256-bitの鍵を用いる. Serpent AES submission.で記述されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;serpent192-cbc&quot; cipher is the same as above, but with a 192-bit
   key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;serpent192-cbc&quot; 暗号は, 同様の暗号だが, 192-bit の鍵を使う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;serpent128-cbc&quot; cipher is the same as above, but with a 128-bit
   key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;serpent128-cbc&quot; 暗号は, 同様の暗号だが, 128-bit の鍵を使う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Arcfour cipher is believed to be compatible with the RC4 cipher
   [SCHNEIER].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Arcfour 暗号は, RC4 暗号 [SCHNEIER] と互換すると考えられている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arcfour (and RC4) has problems with weak keys, and
   should be used with caution.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Arcfour (と RC4) には弱い鍵の問題がある. 注意しながら利用するべきだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;cast128-cbc&quot; cipher is the CAST-128 cipher in CBC mode with a
   128-bit key [RFC2144].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;cast128-cbc&quot; 暗号は, CBCモードで l28-bitの鍵を用いる CAST-128 暗号だ [RFC2144].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this method provides no confidentiality protection, and it
   is NOT RECOMMENDED.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方法は機密性の保護を提供しないことに注意. そしてこの方法は推奨されない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some functionality (e.g., password
   authentication) may be disabled for security reasons if this cipher
   is chosen.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この暗号を用いる場合は, いくつかの機能(たとえば, パスワード認証)がセキュリティ上の理由から無効にされるだろう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional methods may be defined as specified in [SSH-ARCH] and in
   [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加の方法が, [SSH-ARCH] や [SSH-NUMBERS] で定義されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data integrity is protected by including with each packet a MAC that
   is computed from a shared secret, packet sequence number, and the
   contents of the packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのパケットにMACが含まれるとによりデータの完全性が保護される. MACは, 共有の秘密, パケットのシーケンス番号, パケットの中身から計算される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message authentication algorithm and key are negotiated during
   key exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージ認証アルゴリズムと鍵は, 鍵交換の間に取り決められる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initially, no MAC will be in effect, and its length
   MUST be zero.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初は, MACは有効ではなく, その長さは 0 でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After key exchange, the 'mac' for the selected MAC
   algorithm will be computed before encryption from the concatenation
   of packet data:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換の後で, 選択された MACによる 'mac' が, パケットデータの連結を暗号化する前に計算される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where unencrypted_packet is the entire packet without 'mac' (the
   length fields, 'payload' and 'random padding'), and sequence_number
   is an implicit packet sequence number represented as uint32.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>unencrypted_packet は, 'mac' を除くパケット全体(the
   length fields, 'payload', 'random padding')だ. sequence_number は, uint32 で表現される明示されないパケットのシーケンス番号だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   sequence_number is initialized to zero for the first packet, and is
   incremented after every packet (regardless of whether encryption or
   MAC is in use).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>sequence_number は, 最初のパケットで 0 に初期化される. そして(暗号化やMACの使用にかかわらず) すべてのパケットごとに増加される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is never reset, even if keys/algorithms are
   renegotiated later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これはけっしてリセットされない. たとえ鍵やアルゴリズムが再度取り決められた後でもだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It wraps around to zero after every 2^32
   packets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, 2^32 パケットの後で 0 に戻る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The packet sequence_number itself is not included in the
   packet sent over the wire.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>パケットの sequence_number 自体は, 通信で送られるパケットには含まれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MAC algorithms for each direction MUST run independently, and
   implementations MUST allow choosing the algorithm independently for
   both directions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MACのアルゴリズムは, 通信の方向それぞれで独立に動作しなければならない. また, 実装は方向それぞれについてアルゴリズムを独立に選択できなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice however, it is RECOMMENDED that the
   same algorithm be used in both directions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかしながら実際上は, どちらの方向でも同じアルゴリズムを用いることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of 'mac' resulting from the MAC algorithm MUST be
   transmitted without encryption as the last part of the packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>MAC アルゴリズムによって計算された 'mac' の値は, パケットの最後の部分に暗号化なしで転送されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   number of 'mac' bytes depends on the algorithm chosen.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'mac' のバイト数は, 選ばれたアルゴリズムに依存する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;*-n&quot; MACs
   use only the first n bits of the resulting value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;*-n&quot; MACは, 結果の値の最初の n bit のみを利用する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional methods may be defined, as specified in [SSH-ARCH] and in
   [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加の方法が, [SSH-ARCH] や [SSH-NUMBERS] で定義されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key exchange method specifies how one-time session keys are
   generated for encryption and for authentication, and how the server
   authentication is done.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換法は, 暗号と認証のための一時的なセッション鍵がどう作られるかとサーバ認証がどう行なわれるかを指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   name &quot;diffie-hellman-group1-sha1&quot; is used for a key exchange method
   using an Oakley group, as defined in [RFC2409].</seg>
      </tuv>
      <tuv lang="JA">
        <seg> 名前 &quot;diffie-hellman-group1-sha1&quot; は, [RFC2409]で定義されている Oakley群を用いる鍵交換法のために用いられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>SSH maintains its
   own group identifier space that is logically distinct from Oakley
   [RFC2412] and IKE; however, for one additional group, the Working
   Group adopted the number assigned by [RFC3526], using diffie-
   hellman-group14-sha1 for the name of the second defined group.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSHは, Oakley [RFC2412] や IKE と論理的に異なる, 自身の群識別子を維持している. しかし, 追加の群として, ワーキンググループは[RFC3526] で割当てられた数を採用した. この2つ目の群の名前として, &quot;diffie-hellman-group14-sha1&quot; を用いる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations should treat these names as opaque identifiers and
   should not assume any relationship between the groups used by SSH and
   the groups defined for IKE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は, これらの名前を内部識別子として扱わなければならない. また, SSHが用いる群とIKEで定義された群との間の関係を仮定してはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This protocol has been designed to operate with almost any public key
   format, encoding, and algorithm (signature and/or encryption).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, 公開鍵フォーマット, エンコーディング, アルゴリズム (署名と/ないし暗号化) のほとんどのものと共に動作するように設計されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Key format: how is the key encoded and how are certificates
      represented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  鍵フォーマット: どのように鍵がエンコードされ証明書が示されるか.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key blobs in this protocol MAY contain
      certificates in addition to keys.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルの key blob は 鍵に加えて証明書も含んでもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some key types may not
      support both signing and encryption.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の種類の中には, 署名と暗号化の両方をサポートしないものがある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key usage may also be
      restricted by policy statements (e.g., in certificates).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の利用法は, (たとえば証明書の中での)ポリシーの記述によって制限されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this
      case, different key types SHOULD be defined for the different
      policy alternatives.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合, ポリシーの異なる選択肢に対しては異なる鍵の種類が定義されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This includes but
      is not limited to padding, byte order, and data formats.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, パディング, バイトオーダー, データフォーマットを含んでいる. それ以外のものも含まれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ylonen &amp;  Lonvick           Standards Track                    [Page 13]
 
RFC 4253              SSH Transport Layer Protocol          January 2006</seg>
      </tuv>
      <tuv lang="JA">
        <seg>lonen &amp;  Lonvick           Standards Track                    [Page 13]
 
RFC 4253              SSH Transport Layer Protocol          January 2006</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following public key and/or certificate formats are currently
   defined:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の公開鍵と/ないし証明書のフォーマットが現在定義されている:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional key types may be defined, as specified in [SSH-ARCH] and
   in [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加の鍵の種類が, [SSH-ARCH] や [SSH-NUMBERS] で定義されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key type MUST always be explicitly known (from algorithm
   negotiation or some other source).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の種類は, (アルゴリズムの取り決めや他のソースによって)常に明示的に知られてなければならない</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is not normally included in
   the key blob.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>通常, key blob には含まれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The certificate part may be a zero length string, but a public key is
   required.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>certificate の部分は 長さ0の string の場合ががある. 一方 public key は必須だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the public key that will be used for
   authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この公開鍵は認証に利用される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The certificate sequence contained in the
   certificate blob can be used to provide authorization.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>承認の提供が利用できるように, 証明書のシーケンスが, certificate blob に含まれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public key/certificate formats that do not explicitly specify a
   signature format identifier MUST use the public key/certificate
   format identifier as the signature identifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>明示的に署名のフォーマット識別子が指定されていない公開鍵/証明書のフォーマットは, 署名の識別子として鍵/証明書フォーマット識別子を利用しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, the 'p', 'q', 'g', and 'y' parameters form the signature key
   blob.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで, パラメータ 'p', 'q', 'g', 'y'は署名のkey blob を生成する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signing and verifying using this key format is done according to the
   Digital Signature Standard [FIPS-186-2] using the SHA-1 hash
   [FIPS-180-2].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この鍵フォーマットでの署名と検証は, SHA-1 ハッシュ [FIPS-180-2] を用いるDigital Signature Standard [FIPS-186-2] に従って行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value for 'dss_signature_blob' is encoded as a string containing
   r, followed by s (which are 160-bit integers, without lengths or
   padding, unsigned, and in network byte order).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'dss_signature_blob' の値は, (それぞれ長さやパディングがない符号無しのネットワークバイトオーダーの160-bitの整数である) r とそれに続く s を含む文字列としてエンコードされる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Signing and verifying using this key format is performed according to
   the RSASSA-PKCS1-v1_5 scheme in [RFC3447] using the SHA-1 hash.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この鍵フォーマットでの署名と検証は, SHA-1 ハッシュを用いる RSASSA-PKCS1-v1_5 scheme in [RFC3447] に従って行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value for 'rsa_signature_blob' is encoded as a string containing
   s (which is an integer, without lengths or padding, unsigned, and in
   network byte order).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'rsa_signature_blob' の値は,(長さやパディングがない符号無しのネットワークバイトオーダーの160-bitの整数である) s を含む文字列としてエンコードされる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;pgp-sign-rsa&quot; method indicates the certificates, the public key,
   and the signature are in OpenPGP compatible binary format
   ([RFC2440]).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;pgp-sign-rsa&quot; 法は, OpenPGP 互換バイナリフォーマット ([RFC2440]) による証明書と公開鍵, 署名を示している</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;pgp-sign-dss&quot; is as above, but indicates that the key is a
   DSS-key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;pgp-sign-dss&quot; も同様だが, 鍵が DSS鍵であることを示している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key exchange (kex) begins by each side sending name-lists of
   supported algorithms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換 (kex) は, それぞれの側がサポートするアルゴリズムの名前のリストを送ることで始まる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each side has a preferred algorithm in each
   category, and it is assumed that most implementations, at any given
   time, will use the same preferred algorithm.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの側が, それぞれのカテゴリについて優先するアルゴリズムがある. そして, ほとんどの実装で, 常に同じ優先のアルゴリズムを用いると仮定できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which algorithm the other side is using, and MAY send an initial key
   exchange packet according to the algorithm, if appropriate for the
   preferred method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの側も, もう一方の側が用いるアルゴリズムを推測してもよい. また, 優先の方法にとって適切ならば, そのアルゴリズムに従った初期鍵交換パケットを送ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  the kex algorithm and/or the host key algorithm is guessed wrong
      (server and client have different preferred algorithm), or</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  鍵交換アルゴリズムと/ないしホスト鍵のアルゴリズムが間違って推測された(サーバとクライアントが異なる優先アルゴリズムを持つ), ないし</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  if any of the other algorithms cannot be agreed upon (the
      procedure is defined below in Section 7.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  どのアルゴリズムでの同意できなかった(この同意の手順は 7.1 節で後述する).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the guess is considered to be right, and the
   optimistically sent packet MUST be handled as the first key exchange
   packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さもなければ, 推測が正しいと考え, 楽観的に送られたパケットは最初の鍵交換パケットとして扱われなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, if the guess was wrong, and a packet was optimistically sent
   by one or both parties, such packets MUST be ignored (even if the
   error in the guess would not affect the contents of the initial
   packet(s)), and the appropriate side MUST send the correct initial
   packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 推測が間違っていて, かつパケットが一方ないし両方の側から楽観的に送られたなら, それらのパケットが無視されなければならない (たとえ推測のエラーが最初のパケットの内容に影響しなくても). また, 適切な側が正しい初期パケットを送らなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key exchange method uses explicit server authentication if the key
   exchange messages include a signature or other proof of the server's
   authenticity.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換のメッセージが署名やサーバの信頼性を証明するなにかを含んでいるなら, 鍵交換法は明示的なサーバ認証を用いる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A key exchange method uses implicit server
   authentication if, in order to prove its authenticity, the server
   also has to prove that it knows the shared secret, K, by sending a
   message and a corresponding MAC that the client can verify.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバの信頼性を証明するために, クライアントがメッセージと関連するMACを検証するためにサーバが共有の秘密 K を知っていることを示す必要がある場合には, 鍵交換法は暗黙のサーバ認証を用いる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key exchange method defined by this document uses explicit server
   authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この文書で定義される鍵交換法は明示的なサーバ認証を用いる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, key exchange methods with implicit server
   authentication MAY be used with this protocol.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 暗黙のサーバ認証を用いる鍵交換法をこのプロトコルで用いてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After a key exchange
   with implicit server authentication, the client MUST wait for a
   response to its service request message before sending any further
   data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙のサーバ認証での鍵交換の後で, クライアントは, 他のデータを送る前にサービスの要求メッセージに対する返答を待たなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each of the algorithm name-lists MUST be a comma-separated list of
   algorithm names (see Algorithm Naming in [SSH-ARCH] and additional
   information in [SSH-NUMBERS]).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズムの名前リストのそれぞれは, アルゴリズム名のカンマ区切りリストでなければならない ( [SSH-ARCH] の Algorithm Naming と [SSH-NUMBERS] の追加の情報を参照).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each supported (allowed) algorithm
   MUST be listed in order of preference, from most to least.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれのサポートする(許可する)アルゴリズムは, 優先度の降順にリストされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first algorithm in each name-list MUST be the preferred (guessed)
   algorithm.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの名前リストの最初のアルゴリズムが, 優先する(推測する)アルゴリズムでなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>cookie
         The 'cookie' MUST be a random value generated by the sender.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>cookie
         'cookie' は, 送り手が生成するランダムな値でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its purpose is to make it impossible for either side to fully
         determine the keys and the session identifier.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一方の側が完全に鍵やセッション識別子を決めるのを防ぐために使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>kex_algorithms
         Key exchange algorithms were defined above.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>kex_algorithms
         前述した鍵交換アルゴリズムのリスト</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first
         algorithm MUST be the preferred (and guessed) algorithm.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のアルゴリズムが, 優先する(そして推測する)アルゴリズムでなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
         both sides make the same guess, that algorithm MUST be used.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし, 両方の側が同じ推測をしていたら, そのアルゴリズムが使われなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the following algorithm MUST be used to choose a key
         exchange method: Iterate over client's kex algorithms, one at a
         time.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さもなければ, それに続くアルゴリズムが鍵交換法として使われなければならない: クライアントの鍵交換アルゴリズムが1つずつ反復される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Choose the first algorithm that satisfies the following
         conditions:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次の条件を満たす最初のアルゴリズムを選択する:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+  if the algorithm requires an encryption-capable host key,
            there is an encryption-capable algorithm on the server's
            server_host_key_algorithms that is also supported by the
            client, and</seg>
      </tuv>
      <tuv lang="JA">
        <seg>+  そのアルゴリズムが暗号化可能なホスト鍵を必要とするなら, クライアントとサーバ双方の server_host_key_algorithms に挙げられた暗号化可能アルゴリズムである.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>+  if the algorithm requires a signature-capable host key,
            there is a signature-capable algorithm on the server's
            server_host_key_algorithms that is also supported by the
            client.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>+  もしアルゴリズムが署名可能なホスト鍵を必要とするなら, クライアントとサーバ双方の server_host_key_algorithms に挙げられた署名可能なアルゴリズムである.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no algorithm satisfying all these conditions can be found, the
      connection fails, and both sides MUST disconnect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この条件を満たすアルゴリズムが見付からない場合は, 接続は失敗し, 両方の側が切断しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>server_host_key_algorithms
         A name-list of the algorithms supported for the server host
         key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>server_host_key_algorithms
         サポートするサーバホスト鍵のアルゴリズムの名前リスト.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server lists the algorithms for which it has host
         keys; the client lists the algorithms that it is willing to
         accept.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, 保有するホスト鍵のアルゴリズムを挙げる. クライアントは, 受け入れられるアルゴリズムのリストを挙げる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There MAY be multiple host keys for a host, possibly
         with different algorithms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホストに対して, 場合によっては異なるアルゴリズムを用いる, 複数のホスト鍵があってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some host keys may not support both signatures and encryption
         (this can be determined from the algorithm), and thus not all
         host keys are valid for all key exchange methods.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホスト鍵によっては, 署名と暗号化の両方をサポートしない(これはアルゴリズムによって決まる). このため, すべてのホスト鍵がすべての鍵交換法で有効とはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Algorithm selection depends on whether the chosen key exchange
         algorithm requires a signature or an encryption-capable host
         key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズムの選択は, 選択された鍵交換アルゴリズムが署名ないし暗号化可能なホスト鍵を必要とするかどうかに依存する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It MUST be possible to determine this from the public key
         algorithm name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズムは, 公開鍵アルゴリズム名から決められなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first algorithm on the client's name-list
         that satisfies the requirements and is also supported by the
         server MUST be chosen.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントの名前リストの最初のアルゴリズムが, この必要条件を満たしサーバもサポートしているなら, 選ばれなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no such algorithm, both
         sides MUST disconnect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなアルゴリズムがなければ, 両方の側が切断しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>encryption_algorithms
         A name-list of acceptable symmetric encryption algorithms (also
         known as ciphers) in order of preference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>encryption_algorithms
         受け入れ可能な対称暗号化アルゴリズム( cipher としても知られる) の優先度順の名前リスト.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The chosen
         encryption algorithm to each direction MUST be the first
         algorithm on the client's name-list that is also on the
         server's name-list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの方向の選択される暗号化アルゴリズムは, サーバの名前リストに存在するものの中でクライアントの名前リストの最初にあるアルゴリズムでなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there is no such algorithm, both sides
         MUST disconnect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そのようなアルゴリズムがなければ, 両方の側が切断しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &quot;none&quot; must be explicitly listed if it is to be
         acceptable.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;none&quot; が受け入れられる場合には, 明示的に挙げなければならないことに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The defined algorithm names are listed in Section
         6.3.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>定義済みのアルゴリズム名は, 6.3  節に挙げられている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mac_algorithms
         A name-list of acceptable MAC algorithms in order of
         preference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>mac_algorithms
         受け入れ可能なMACアルゴリズムの優先度順の名前リスト.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The chosen MAC algorithm MUST be the first
         algorithm on the client's name-list that is also on the
         server's name-list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>選択されるMACアルゴリズムは, サーバの名前リストに存在するものの中でクライアントの名前リストの最初にあるアルゴリズムでなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>compression_algorithms
         A name-list of acceptable compression algorithms in order of
         preference.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>compression_algorithms
         受け入れ可能な圧縮アルゴリズムの優先度順の名前リスト.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The chosen compression algorithm MUST be the first
         algorithm on the client's name-list that is also on the
         server's name-list.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>選択される圧縮アルゴリズムは, サーバの名前リストに存在するものの中でクライアントの名前リストの最初にあるアルゴリズムでなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The compression algorithm names are listed in
         Section 6.2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮アルゴリズム名は, 6.2節に挙げられている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>languages
         This is a name-list of language tags in order of preference
         [RFC3066].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>languages
         優先度順の言語タグ名前リストだ [RFC3066].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there
         are no language preferences, this name-list SHOULD be empty as
         defined in Section 5 of [SSH-ARCH].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>優先する言語がなければ, この名前リストは, [SSH-ARCH] の 5節で定義したように空の必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Language tags SHOULD NOT
         be present unless they are known to be needed by the sending
         party.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>送り手側で必要だとされていなければ, 言語タグは存在しないほうがよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first_kex_packet_follows
         Indicates whether a guessed key exchange packet follows.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>first_kex_packet_follows
         推測された鍵交換パケット後に続くかどうかを示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a
         guessed packet will be sent, this MUST be TRUE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>推測されたパケットが送られる場合, これは TRUE でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no guessed
         packet will be sent, this MUST be FALSE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>推測されたパケットが送られないなら, これは, FALSE でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After receiving the SSH_MSG_KEXINIT packet from the other side,
         each party will know whether their guess was right.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一方の側から SSH_MSG_KEXINIT パケットを受け取った後で, それぞれの側は推測が正しいか知る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the
         other party's guess was wrong, and this field was TRUE, the
         next packet MUST be silently ignored, and both sides MUST then
         act as determined by the negotiated key exchange method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一方の側の推測が間違っていてこのフィールドがTRUEなら, 次のパケットは静かに無視されなければならない. そして, 両方の側は取り決められた鍵交換法によって決められた行動をしなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
         the guess was right, key exchange MUST continue using the
         guessed packet.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>推測が正しければ, 鍵交換は推測されたパケットを用いて続けられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After the SSH_MSG_KEXINIT message exchange, the key exchange
   algorithm is run.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_KEXINIT メッセージが交換されたら, 鍵交換アルゴリズムが動作する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may involve several packet exchanges, as
   specified by the key exchange method.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換法の指定によっては, 複数のパケットの交換が行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a party has sent a SSH_MSG_KEXINIT message for key exchange or
   re-exchange, until it has sent a SSH_MSG_NEWKEYS message (Section
   7.3), it MUST NOT send any messages other than:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一度, 一方の側が 鍵交換ないし鍵の再交換のために SSH_MSG_KEXINIT メッセージを送ったら, SSH_MSG_NEWKEYS メッセージを送るまで (7.3節参照) 以下以外のメッセージを送ってはならない:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Transport layer generic messages (1 to 19) (but
      SSH_MSG_SERVICE_REQUEST and SSH_MSG_SERVICE_ACCEPT MUST NOT be
      sent);</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  トランスポート層の一般メッセージ (1 to 19) (しかし, SSH_MSG_SERVICE_REQUEST と SSH_MSG_SERVICE_ACCEPT は 送ってはならない);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Algorithm negotiation messages (20 to 29) (but further
      SSH_MSG_KEXINIT messages MUST NOT be sent);</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  アルゴリズムネゴシエーションメッセージ (20 to 29) (しかし, さらなる SSH_MSG_KEXINIT メッセージは送ってはならない);</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, however, that during a key re-exchange, after sending a
   SSH_MSG_KEXINIT message, each party MUST be prepared to process an
   arbitrary number of messages that may be in-flight before receiving a
   SSH_MSG_KEXINIT message from the other party.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, SSH_MSG_KEXINIT が送られた後の鍵交換の間に, もう一方の側から SSH_MSG_KEXINIT メッセージを受け取るまでは 送信中かもしれない任意の番号のメッセージを処理する準備がされていなければならないことに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key exchange produces two values: a shared secret K, and an
   exchange hash H.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵交換は2つの値を生成する: 共有の秘密 K と 交換ハッシュ H だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption and authentication keys are derived from
   these.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号化と認証の鍵はこれらから導出される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exchange hash H from the first key exchange is
   additionally used as the session identifier, which is a unique
   identifier for this connection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初の鍵交換からの交換ハッシュ H は, 接続の唯一の識別子として, セッション識別子としても使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is used by authentication methods
   as a part of the data that is signed as a proof of possession of a
   private key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは, 認証法の中で, 秘密鍵の所有を証明するために署名されるデータの一部として使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once computed, the session identifier is not changed,
   even if keys are later re-exchanged.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一度計算されたら, セッション識別子は変更されない. たとえ, あとで鍵を再交換してもだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each key exchange method specifies a hash function that is used in
   the key exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それぞれの鍵交換法は, 鍵交換で使うハッシュ関数を指定している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same hash algorithm MUST be used in key
   derivation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の導出にも同じハッシュアルゴリズムが用いられなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption keys MUST be computed as HASH, of a known value and K, as
   follows:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号鍵は, 既知の値とKに対する HASH によって次のように計算されなければならない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  Initial IV client to server: HASH(K || H || &quot;A&quot; || session_id)
      (Here K is encoded as mpint and &quot;A&quot; as byte and session_id as raw
      data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  クライアンントからサーバへの初期 IV : HASH(K || H || &quot;A&quot; || session_id (ここで, K は mpint に, &quot;A&quot; は バイトに, session_id は 生データとしてエンコードされる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As
   many bytes as needed are taken from the beginning of the hash value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>必要なバイト数を, ハッシュの値の最初から取得する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the key length needed is longer than the output of the HASH, the
   key is extended by computing HASH of the concatenation of K and H and
   the entire key so far, and appending the resulting bytes (as many as
   HASH generates) to the key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>HASHの出力よりも必要な鍵長が長い場合は, K と H とそれまでの鍵すべてを連結したものの HASH を計算し結果のバイトを(HASHが生成するのと同じだけ)追加して鍵は拡張される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process is repeated until enough
   key material is available; the key is taken from the beginning of
   this value.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロセスは, 鍵の素材が十分な長さになるまで繰替えされる; そして鍵はこの素材の最初から取得される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process will lose entropy if the amount of entropy in K is
   larger than the internal state size of HASH.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロセスは, Kのエントロピー量がHASHの内部状態のサイズよりも大きい場合, エントロピーを失なう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All messages
   sent after this message MUST use the new keys and algorithms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージの後のすべてのメッセージは, 新しい鍵とアルゴリズムで送られなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this message is received, the new keys and algorithms MUST be
   used for receiving.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージを受け取ったら, 新しい鍵とアルゴリズムを受信に利用しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of this message is to ensure that a party is able to
   respond with an SSH_MSG_DISCONNECT message that the other party can
   understand if something goes wrong with the key exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージの目的は, 鍵交換で何か問題があったかどうかをもう一方の側が理解できるように SSH_MSG_DISCONNECT メッセージを返信できることを保証することだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Diffie-Hellman (DH) key exchange provides a shared secret that
   cannot be determined by either party alone.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>Diffie-Hellman (DH) 鍵交換は, 一方の側だけでは決定できない共有の秘密を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key exchange is
   combined with a signature with the host key to provide host
   authentication.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この鍵交換は, ホスト認証を提供するホスト鍵による署名と結合している.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This key exchange method provides explicit server
   authentication as defined in Section 7.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この鍵交換法は,  7節で定義した 明示的なサーバ認証を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this, C is the
   client; S is the server; p is a large safe prime; g is a generator
   for a subgroup of GF(p); q is the order of the subgroup; V_S is S's
   identification string; V_C is C's identification string; K_S is S's
   public host key; I_C is C's SSH_MSG_KEXINIT message and I_S is S's
   SSH_MSG_KEXINIT message that have been exchanged before this part
   begins.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ここで, C はクライアント; S はサーバ; p は大きく安全な素数; g は GF(p) 部分群の生成子; q は部分群のオーダー; V_S は S の識別文字列; V_C は C の識別文字列; K_S は S のホスト公開鍵; I_C は C の SSH_MSG_KEXINIT メッセージ;  I_S は, この処理が始まる前に交換される S の SSH_MSG_KEXINIT メッセージだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C generates a random number x (1 &lt; x &lt; q) and computes
      e = g^x mod p.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C は, 乱数 x (1 &lt; x &lt; q) を生成し, e = g^x mod p を計算する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S generates a random number y (0 &lt; y &lt; q) and computes
      f = g^y mod p.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S  は乱数 y (0 &lt; y &lt; q) を生成し f = g^y mod p を計算する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It computes K = e^y mod p,
      H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K)
      (these elements are encoded according to their types; see below),
      and signature s on H with its private host key.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>K = e^y mod p と H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K) を計算する (これらの要素はそれぞれの種類に従ってエンコードされる. 以下を参照). そして, ホスト秘密鍵で H に署名する. 署名の結果は s とする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>S sends
      (K_S || f || s) to C.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>S は (K_S || f || s) を C に送る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The signing operation may involve a
      second hashing operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>署名の操作は2回目のハッシュの操作をするかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C verifies that K_S really is the host key for S (e.g., using
      certificates or a local database).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C は, K_S が本当に S のホスト鍵かを検証する(例えば, 証明書やローカルなデータベースを用いて).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C is also allowed to accept
      the key without verification; however, doing so will render the
      protocol insecure against active attacks (but may be desirable for
      practical reasons in the short term in many environments).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>C は, 鍵を検証無しで受け入れることもできる; しかし, そうするとプロトコルを能動的な攻撃に対して安全ではなくしてしまう (しかし, 多くの環境で短い期間実際的な理由から望まれている).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C then
      computes K = f^x mod p, H = hash(V_C || V_S || I_C || I_S || K_S
      || e || f || K), and verifies the signature s on H.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>そして C は K = f^x mod p と H = hash(V_C || V_S || I_C || I_S || K_S || e || f || K)を計算し H に対する署名 s を検証する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Values of 'e' or 'f' that are not in the range [1, p-1] MUST NOT be
   sent or accepted by either side.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>[1, p-1] の範囲ではない'e' や 'f' の値は, どちらの側も送ったり受け取ったりしてはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this condition is violated, the
   key exchange fails.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この条件が破られたら, 鍵交換は失敗する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hash algorithm
   for computing the exchange hash is defined by the method name, and is
   called HASH.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>交換ハッシュを計算するハッシュ関数は, 方法の名前で定義される. これを HASH と呼ぶ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The public key algorithm for signing is negotiated with
   the SSH_MSG_KEXINIT messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>署名に用いる公開鍵アルゴリズムは, SSH_MSG_KEXINIT メッセージで取り決める.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The hash H is computed as the HASH hash of the concatenation of the
   following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ハッシュ H は, 次の連結に対する HASH の結果だ:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This value is called the exchange hash, and it is used to
   authenticate the key exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この値は交換ハッシュと呼ばれる. 鍵交換を認証するのに用いられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exchange hash SHOULD be kept
   secret.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>交換ハッシュは秘密にする必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The signature algorithm MUST be applied over H, not the original
   data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>元データではなく H に対して署名のアルゴリズムが適用されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Most signature algorithms include hashing and additional
   padding (e.g., &quot;ssh-dss&quot; specifies SHA-1 hashing).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>殆どの署名のアルゴリズムは, ハッシュと追加のパディングを含んでいる(たとえば, 'ssh-dss' は SHA-1 ハッシュを指定する).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In that case, the
   data is first hashed with HASH to compute H, and H is then hashed
   with SHA-1 as part of the signing operation.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この場合, データはまず H を計算するために HASH でハッシュされ, そして署名の計算の一部分として SHA-1 でハッシュされる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;diffie-hellman-group1-sha1&quot; method specifies the Diffie-Hellman
   key exchange with SHA-1 as HASH, and Oakley Group 2 [RFC2409] (1024-
   bit MODP Group).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;diffie-hellman-group1-sha1&quot; 法は, HASH として SHA-1 またOakley Group 2 [RFC2409] (1024-bit MODP Group)を用いる Diffie-Hellman 鍵交換を指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method MUST be supported for interoperability
   as all of the known implementations currently support it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方法は, 現在知られている実装はすべてサポートしているので, 相互運用性のためにサポートされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that
   this method is named using the phrase &quot;group1&quot;, even though it
   specifies the use of Oakley Group 2.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この方法は, Oakley Group 2の利用を指定しているのに &quot;group1&quot; を用いて名前付けされていることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;diffie-hellman-group14-sha1&quot; method specifies a Diffie-Hellman
   key exchange with SHA-1 as HASH and Oakley Group 14 [RFC3526] (2048-
   bit MODP Group), and it MUST also be supported.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>&quot;diffie-hellman-group14-sha1&quot; 法は, HASH として SHA-1 またOakley Group 14 [RFC3526] (2048-bit MODP Group)を用いる Diffie-Hellman 鍵交換を指定する. そしてこの方法もサポートされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key re-exchange is started by sending an SSH_MSG_KEXINIT packet when
   not already doing a key exchange (as described in Section 7.1).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の再交換は, (7.1 節で記述した) 鍵交換をまだ行なっていない場合にも送られる SSH_MSG_KEXINIT パケットの送信によって始められる. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When
   this message is received, a party MUST respond with its own
   SSH_MSG_KEXINIT message, except when the received SSH_MSG_KEXINIT
   already was a reply.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージを受信したら, 受け取った側は自身の SSH_MSG_KEXINIT メッセージを送らなければならない. ただし, 受け取った SSH_MSG_KEXINIT が返信の場合は除く.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Either party MAY initiate the re-exchange, but
   roles MUST NOT be changed (i.e., the server remains the server, and
   the client remains the client).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの側も, 鍵の再交換を始めてもよい. ただし, 役割を変更してはならない (すなわち, サーバはサーバのままでクライアントはクライアントのままでなければならない).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Key re-exchange is performed using whatever encryption was in effect
   when the exchange was started.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の再交換は, 交換は始まる際に有効な暗号化などをすべて用いて行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encryption, compression, and MAC
   methods are not changed before a new SSH_MSG_NEWKEYS is sent after
   the key exchange (as in the initial key exchange).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗号化, 圧縮, MAC は, (最初の鍵交換と同様に) 鍵交換の後で  新しい SSH_MSG_NEWKEYS が送られるまでは変更されない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Re-exchange is
   processed identically to the initial key exchange, except for the
   session identifier that will remain unchanged.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>再交換は, セッション識別子が変更されないことを除くと, 最初の鍵交換と同様に処理される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is permissible to
   change some or all of the algorithms during the re-exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>鍵の再交換でいくつかないしすべてのアルゴリズムを変更することが許されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Host
   keys can also change.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ホスト鍵も変更できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All keys and initialization vectors are
   recomputed after the exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>交換のあとで, すべての鍵と初期化ベクトルが再計算される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compression and encryption contexts
   are reset.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>圧縮と暗号化のコンテキストはリセットされる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is RECOMMENDED that the keys be changed after each gigabyte of
   transmitted data or after each hour of connection time, whichever
   comes sooner.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>転送データが1ギガバイトになるたびもしくは接続時間1時間経過のたび, どちらか早い方の後で, 鍵を変更することが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, since the re-exchange is a public key
   operation, it requires a fair amount of processing power and should
   not be performed too often.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 鍵交換は公開鍵の操作で, かなりの処理量を必要とするので頻繁に行ないすぎないほうがよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More application data may be sent after the SSH_MSG_NEWKEYS packet
   has been sent; key exchange does not affect the protocols that lie
   above the SSH transport layer.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_NEWKEYS が送られた後で, さらなるアプリケーションのデータが送られるだろう; 鍵交換はSSHトランスポート層の上位のプロトコルには影響しない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The service
   is identified by a name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サービスは名前で識別される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format of names and procedures for
   defining new names are defined in [SSH-ARCH] and [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>名前の形式や新しい名前を定義する手続きは, [SSH-ARCH] と [SSH-NUMBERS] で定義されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar local naming policy is applied to the service names, as is
   applied to the algorithm names.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>アルゴリズム名に適用されているのと同様のローカルな名前付けのポリシーが, サービス名にも適用される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A local service should use the
   PRIVATE USE syntax of &quot;servicename@domain&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ローカルなサービス名は, &quot;servicename@domain&quot; という PRIVATE USE な構文を使わなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server rejects the service request, it SHOULD send an
   appropriate SSH_MSG_DISCONNECT message and MUST disconnect.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバがサービスの要求を拒否するなら, 適切な SSH_MSG_DISCONNECT メッセージを送る必要がある. そして 切断しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the service starts, it may have access to the session identifier
   generated during the key exchange.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サービスを開始する場合は, 鍵交換の間に生成されたセッション識別子にアクセスするかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server supports the service (and permits the client to use
   it), it MUST respond with the following:</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバがサービスをサポートし(クライアントによる利用を許可するなら), 次のメッセージを返答しなければならない:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Message numbers used by services should be in the area reserved for
   them (see [SSH-ARCH] and [SSH-NUMBERS]).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サービスで用いられるメッセージ番号は, 予約されている領域のものを利用しなければならない([SSH-ARCH] と [SSH-NUMBERS] を参照).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The transport level will
   continue to process its own messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>トランスポートのレベルでは, トランスポート自身のメッセージを処理し続ける.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that after a key exchange with implicit server authentication,
   the client MUST wait for a response to its service request message
   before sending any further data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>暗黙のサーバ認証での鍵交換の後では, クラアイントは, 他のデータを送る前にサービスの要求メッセージに対する返答を待たなければならないことに注意すること.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All
   implementations MUST be able to process this message; they SHOULD be
   able to send this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての実装は, このメッセージを処理できなければならない; すべての実装はこのメッセージを送信可能である必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The sender MUST NOT send or receive any data after this message, and
   the recipient MUST NOT accept any data after receiving this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>送り手は, このメッセージの後でどんなデータも送ったり受け取ったりしてはならない. 受け取り手はこのメッセージを受け取った後でどんなデータも受け取ってはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Disconnection Message 'description' string gives a more specific
   explanation in a human-readable form.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切断メッセージの 'description' 文字列は, より具体的な説明を人間が読める形で提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Disconnection Message
   'reason code' gives the reason in a more machine-readable format
   (suitable for localization), and can have the values as displayed in
   the table below.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>切断メッセージの 'reason code' は, (地域化に適した)より機械よりの形式で理由を提供する. 以下の表で示す値を持つ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the decimal representation is displayed
   in this table for readability, but the values are actually uint32
   values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この表では読み易いように10進で表記されているが, 実際にはuint32の値であることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the 'description' string is displayed, the control character
   filtering discussed in [SSH-ARCH] should be used to avoid attacks by
   sending terminal control characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'description' 文字列を表示するなら, [SSH-ARCH]での議論のように, 端末の制御文字を利用した攻撃を避けるために制御文字のフィルタを用いる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new Disconnection Message 'reason code'
   values (and associated 'description' text) in the range of 0x00000010
   to 0xFDFFFFFF MUST be done through the IETF CONSENSUS method, as
   described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しい切断メッセージの 'reason code' の値(と関連する 'description') を割り当てる要求は, 0x00000010 から 0xFDFFFFFF の範囲については [RFC2434] に記述されている IETF CONSENSUS におってされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Disconnection Message 'reason code'
   values in the range of 0xFE000000 through 0xFFFFFFFF are reserved for
   PRIVATE USE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0xFE000000 から 0xFFFFFFFF の範囲の 'reason code' の値は, プライベートな利用(PRIVATE USE)に予約されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As noted, the actual instructions to the IANA are in
   [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANA への実際の指示は [SSH-NUMBERS] にあることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All implementations MUST understand (and ignore) this message at any
   time (after receiving the identification string).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての実装は, (識別文字列を受け取った後の)どの時点でもこのメッセージを理解(そして無視)しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No implementation
   is required to send them.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージを送ることは, どの実装にも要求されていない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message can be used as an additional
   protection measure against advanced traffic analysis techniques.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージは, 高度なトラフィック解析技術に対する追加の保護手段のために用いられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All implementations MUST understand this message, but they are
   allowed to ignore it.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての実装はこのメッセージを理解しなければならない. しかし無視してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message is used to transmit information
   that may help debugging.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージは, デバッグを助ける情報を転送するのに使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If 'always_display' is TRUE, the message
   SHOULD be displayed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'always_display' が TRUE なら, メッセージを表示する必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, it SHOULD NOT be displayed unless
   debugging information has been explicitly requested by the user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, ユーザが明示的にデバッグ情報の表示を求めていない場合には表示しないほうがよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is, however,
   allowed to consist of multiple lines separated by CRLF (Carriage
   Return - Line Feed) pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, CRLF (キャリッジリターン - ラインフィード) の組で区切られた複数の行を含んでもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the 'message' string is displayed, the terminal control character
   filtering discussed in [SSH-ARCH] should be used to avoid attacks by
   sending terminal control characters.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'message' 文字列を表示するなら, [SSH-ARCH]での議論のように, 端末の制御文字を利用した攻撃を避けるために制御文字のフィルタを用いる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An implementation MUST respond to all unrecognized messages with an
   SSH_MSG_UNIMPLEMENTED message in the order in which the messages were
   received.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>すべての実装は, すべての認識できないメッセージに対して受け取った順にSSH_MSG_UNIMPLEMENTED メッセージで応答しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Later protocol
   versions may define other meanings for these message types.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>プロトコルのより後のバージョンが, これらのメッセージタイプに別の意味を定義するかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following is a summary of messages and their associated message
   number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>メッセージのまとめと関連するメッセージ番号を以下に示す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Different kex
   methods may reuse message numbers in this range.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>異なる鍵交換法は, この範囲のメッセージ番号を再利用する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IANA considerations for the SSH
   protocol as defined in [SSH-ARCH], [SSH-USERAUTH], [SSH-CONNECT], and
   this document, are detailed in [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>[SSH-ARCH],
   [SSH-USERAUTH],  [SSH-CONNECT] とこの文書で定義される SSH プロトコルに対する IANA の考慮は,  [SSH-NUMBERS]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It performs server host authentication, key exchange,
   encryption, and integrity protection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバの認証, 鍵の交換, 暗号化, 完全性の保護を行なう.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also derives a unique
   session ID that may be used by higher-level protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>さらに, より上位のプロトコルで利用される, ユニークなセッションidを導出する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides
   interactive login sessions, remote execution of commands, forwarded
   TCP/IP connections, and forwarded X11 connections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, インタラクティブなログインセッション, コマンドのリモート実行, TCP/IP接続の転送, X11接続の転送を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these
   channels are multiplexed into a single encrypted tunnel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのチャンネルすべては, 単一の暗号化されたトンネルに多重化される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SSH Connection Protocol has been designed to run on top of the
   SSH transport layer and user authentication protocols.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH コネクションプロトコルは, SSH トランスポート層・ユーザ認証プロトコル上で動作するように設計されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SSH Connection Protocol has been designed to run on top of the
   SSH transport layer and user authentication protocols ([SSH-TRANS]
   and [SSH-USERAUTH]).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH コネクションプロトコルは, SSH トランスポート層・ユーザ認証プロトコル上で動作するように設計されている([SSH-TRANS] と [SSH-USERAUTH]).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It provides interactive login sessions, remote
   execution of commands, forwarded TCP/IP connections, and forwarded
   X11 connections.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプロトコルは, インタラクティブなログインセッション, コマンドのリモート実行, TCP/IP接続の転送, X11接続の転送を提供する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several kinds of requests that affect the state of the
   remote end globally, independent of any channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リモートの状態に全体的に(チャンネルとは独立に)影響する要求がいくつかある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example is a
   request to start TCP/IP forwarding for a specific port.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例を挙げると, 特定のポートに対するTCP/IP転送の開始の要求だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that
   both the client and server MAY send global requests at any time, and
   the receiver MUST respond appropriately.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントもサーバもいつでも全体的な要求を送ってよく受け取り手は適切に返答しなければならないことに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All such requests use the
   following format.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それらの要求はすべて次のフォーマットに従う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of 'request name' follows the DNS extensibility naming
   convention outlined in [SSH-ARCH].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'request name' の値は, [SSH-ARCH] で説明されているDNS 拡張命名規則に従う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The recipient will respond to this message with
   SSH_MSG_REQUEST_SUCCESS or SSH_MSG_REQUEST_FAILURE if 'want reply' is
   TRUE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>受け取り手はこのメッセージに対して, SSH_MSG_REQUEST_SUCCESS か, 'want_reply' が TRUE の SSH_MSG_REQUEST_FAILURE で返答する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the recipient does not recognize or support the request, it simply
   responds with SSH_MSG_REQUEST_FAILURE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>受け取り手が要求を理解しなかったりサポートしない場合は, 単にSSH_MSG_REQUEST_FAILURE を返す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, the reply messages do not include request type
   identifiers.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一般に, この返答メッセージは要求の種類の識別子を含まない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To make it possible for the originator of a request to
   identify to which request each reply refers, it is REQUIRED that
   replies to SSH_MSG_GLOBAL_REQUESTS MUST be sent in the same order as
   the corresponding request messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要求を開始した側がどの要求を参照してるかを識別するのを可能にするために,SSH_MSG_GLOBAL_REQUESTS の返答は, 関連する要求のメッセージと同じ順番で送られなければならないことが要求されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For channel requests, replies
   that relate to the same channel MUST also be replied to in the right
   order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルの要求でも, 同じチャンネルに関係する応答は正しい順番でなされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, channel requests for distinct channels MAY be
   replied to out-of-order.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 別のチャンネルに対する要求には, 順番が入れ変って返答されてもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple channels are multiplexed
   into a single connection.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>複数のチャンネルは, 単一の接続に多重化される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number referring
   to a channel may be different on each side.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルを示す番号は, それぞれの側で異なることがある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests to open a
   channel contain the sender's channel number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>チャンネルを開始する要求は, 送り手のチャンネル番号を含む.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any other channel-
   related messages contain the recipient's channel number for the
   channel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>それ以外のチャンネルに関するメッセージは, そのチャンネルの受け取り手のチャンネル番号を含む.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No data may be sent to a channel until
   a message is received to indicate that window space is available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>window のスペースがあることを示すメッセージが受けとられるまで, チャンネルにはデータは送られない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When either side wishes to open a new channel, it allocates a local
   number for the channel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>一方の側がチャンネルを開始したい時, チャンネルに対してローカルな番号を割り当てる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It then sends the following message to the
   other side, and includes the local channel number and initial window
   size in the message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のメッセージをもう一方の側に送る. メッセージにはローカルなチャンネル番号と初期 window サイズ が含まれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'channel type' is a name, as described in [SSH-ARCH] and
   [SSH-NUMBERS], with similar extension mechanisms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'channel type' は名前で, [SSH-ARCH] と [SSH-NUMBERS] に記述されたような拡張のメカニズムを持つ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'sender
   channel' is a local identifier for the channel used by the sender of
   this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'sender channel' は, このメッセージの送り手が使うチャンネルのローカルな識別子だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'initial window size' specifies how many bytes of
   channel data can be sent to the sender of this message without
   adjusting the window.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'initial window size'は, チャンネルのデータをこのメッセージの送り手にwindow の調整なしで送れる byte 数を指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'maximum packet size' specifies the
   maximum size of an individual data packet that can be sent to the
   sender.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'maximum packet size' は, 送り手に送ることができる1つのデータパケットの最大サイズを指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, one might want to use smaller packets for
   interactive connections to get better interactive response on slow
   links.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば, 遅い回線でよりよいインタラクティブな返答を得るために, インタラクティブな接続で一方の側がより小さいパケットを用いるように求める場合がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The remote side then decides whether it can open the channel, and
   responds with either SSH_MSG_CHANNEL_OPEN_CONFIRMATION or
   SSH_MSG_CHANNEL_OPEN_FAILURE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>リモート側はチャンネルを開始するかどうかを決定する. そして SSH_MSG_CHANNEL_OPEN_CONFIRMATION か SSH_MSG_CHANNEL_OPEN_FAILURE で返答する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'recipient channel' is the channel number given in the original
   open request, and 'sender channel' is the channel number allocated by
   the other side.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'recipient channel' は, 元の開始要求で与えられたチャンネル番号だ. 'sender channel' はもう一方の側で割り当てられたチャンネル番号だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the recipient of the SSH_MSG_CHANNEL_OPEN message does not support
   the specified 'channel type', it simply responds with
   SSH_MSG_CHANNEL_OPEN_FAILURE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_CHANNEL_OPEN メッセージの受け取り手が 指定された 'channel type' をサポートしていないなら, SSH_MSG_CHANNEL_OPEN_FAILURE で単純に返答する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client MAY show the 'description'
   string to the user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, 'description' 文字列をユーザに表示してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is done, the client software should take
   the precautions discussed in [SSH-ARCH].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし表示するなら, クライアントソフトウェアは, [SSH-ARCH]で議論した予防措置を取らなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The SSH_MSG_CHANNEL_OPEN_FAILURE 'reason code' values are defined in
   the following table.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_CHANNEL_OPEN_FAILURE の 'reason code' の値は, 次の表で定義される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the values for the 'reason code' are
   given in decimal format for readability, but they are actually uint32
   values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'reason code' は読み易いように10進のフォーマットで書かれているが, 実際にはuint32の値であることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new SSH_MSG_CHANNEL_OPEN 'reason code'
   values (and associated 'description' text) in the range of 0x00000005
   to 0xFDFFFFFF MUST be done through the IETF CONSENSUS method, as
   described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>新しいSSH_MSG_CHANNEL_OPENの 'reason code' の値(と関連する 'description' テキスト) を割り当てる要求は, 0x00000005 から 0xFDFFFFFF の範囲については [RFC2434] に記述されている IETF CONSENSUS におってされなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The IANA will not assign Channel Connection
   Failure 'reason code' values in the range of 0xFE000000 to
   0xFFFFFFFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANAは, 0xFE000000 から 0xFFFFFFFF の範囲のチャンネル接続失敗の'reason code' の値は割り当てない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if a channel is
      proposed with a 'channel type' of &quot;example_session@example.com&quot;,
      but fails, then the response will contain either a 'reason code'
      assigned by the IANA (as listed above and in the range of
      0x00000001 to 0xFDFFFFFF) or a locally assigned value in the range
      of 0xFE000000 to 0xFEFFFFFF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>たとえば,&quot;example_session@example.com&quot; という 'channel type' のチャンネルが提案されたが失敗したとき, レスポンスには, (前述ないし0x00000001 から 0xFDFFFFFFの範囲の) IANA で割り当てられた 'reason code'が含まれるか,  0xFE000000 から 0xFEFFFFFF の埴のローカルに割り当てられた値を'reason code' が含まれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naturally, if the server does not
      understand the proposed 'channel type', even if it is a locally
      defined 'channel type', then the 'reason code' MUST be 0x00000003,
      as described above, if the 'reason code' is sent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もちろん, サーバが提案された 'channel type' を理解できない場合は, それがローカルに定義された 'channel type' であっても, 'reason code' は 前述した0x00000003 でなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the server
      does understand the 'channel type', but the channel still fails to
      open, then the server SHOULD respond with a locally assigned
      'reason code' value consistent with the proposed, local 'channel
      type'.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバが 'channel type' を理解するがチャンネルの開始に失敗するなら, サーバは提案されたローカルな 'channel type' に対応するローカルに割り当てられた値を返す必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is assumed that practitioners will first attempt to use
      the IANA assigned 'reason code' values and then document their
      locally assigned 'reason code' values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実行する者が, まずIANAで割り当てられた 'reason code' を利用しようとし, その次にローカルに割り当てられた 'reason code' を利用しようとすることを前提としている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window size specifies how many bytes the other party can send
   before it must wait for the window to be adjusted.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>window size は, windowが調整されるまでにもう一方の側が送ることのできるバイト数を指定する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both parties use
   the following message to adjust the window.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの側も次のメッセージで window を調整できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After receiving this message, the recipient MAY send the given number
   of bytes more than it was previously allowed to send; the window size
   is incremented.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージを受け取ったら, 受け取り手は以前送る事を許可されていたものよりも指定されただけ大きいbyte数を送ってもよい; window size が増加する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations MUST correctly handle window sizes
   of up to 2^32 - 1 bytes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は, 2^32 -1 byteまでのwindow size を正しく扱えなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window MUST NOT be increased above
   2^32 - 1 bytes.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>2＾32 - 1 byte を越えて window が拡大されることはない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximum amount of data allowed is determined by the maximum
   packet size for the channel, and the current window size, whichever
   is smaller.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>許されるデータの最大量は, チャンネルの最大 packet size と現在の window size の小さいほうで決定される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The window size is decremented by the amount of data
   sent.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>window size は, 転送されたデータ量だけ減少する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both parties MAY ignore all extra data sent after the allowed
   window is empty.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>許される window が空になったあとで転送されたすべての余分なデータは, どちらの側も無視してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations are expected to have some limit on the SSH transport
   layer packet size (any limit for received packets MUST be 32768 bytes
   or larger, as described in [SSH-TRANS]).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装には, SSH トランスポート層の packet size に制限があることを期待される (packet の受信のためのどのような制限も, [SSH-TRANS]に記述されているように, 32768 byte 以上でなければならない.).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The implementation of the
   SSH connection layer</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH コネクション層の実装は</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  MUST NOT advertise a maximum packet size that would result in
      transport packets larger than its transport layer is willing to
      receive.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  トランスポート層が受信できるよりも大きなトランスポート packet になる最大 packet size を告知してはならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o  MUST NOT generate data packets larger than its transport layer is
      willing to send, even if the remote end would be willing to accept
      very large packets.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>o  トランスポート層が送れるものよりも大きな data packet を生成してはならない. たとえ, リモート側が非常に大きな packet を受けとりたい場合でもだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An
   example of this is stderr data from interactive sessions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>この例として, インタラクティブなセッションからの stderr データがある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such data
   can be passed with SSH_MSG_CHANNEL_EXTENDED_DATA messages, where a
   separate integer specifies the type of data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このようなデータは, SSH_MSG_CHANNEL_EXTENDED_DATA メッセージによって転送される. ここで異なる integer によってデータの種類を指定する. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The available types and
   their interpretation depend on the type of channel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>利用できる種類とその解釈は, チャンネルの種類に依存する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data sent with these messages consumes the same window as ordinary
   data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージで送られたデータは, 通常のデータと同じ window を消費する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value
   for the 'data_type_code' is given in decimal format for readability,
   but the values are actually uint32 values.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'data_type_code' は読み易いように10進のフォーマットで書かれているが, 実際にはuint32の値であることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Requests for assignments of new Extended
   Channel Data Transfer 'data_type_code' values and their associated
   Extended Channel Data Transfer 'data' strings, in the range of
   0x00000002 to 0xFDFFFFFF, MUST be done through the IETF CONSENSUS
   method as described in [RFC2434].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張チャンネルデータ転送の 'data_type_code' の値と関連する拡張チャンネルデータ転送の 'data' を割り当てる要求は, 0x00000002 から 0xFDFFFFFF の範囲については [RFC2434] に記述されている IETF CONSENSUS によってされなければならない. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As is noted, the actual instructions to the
   IANA are in [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>IANA への実際の指示は [SSH-NUMBERS] にあることに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a party will no longer send more data to a channel, it SHOULD
   send SSH_MSG_CHANNEL_EOF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらかの側がチャンネルにもうこれ以上データを送らないなら, SSH_MSG_CHANNEL_EOF を送る必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the
   application may send EOF to whatever is at the other end of the
   channel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, チャンネルのもう一方の側が終了したときに, アプリケーションが EOF を送るかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the channel remains open after this message, and
   more data may still be sent in the other direction.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージのあともチャンネルは開かれた状態で残り, もう一方の方向でさらなるデータが送られるかもしれないことに注意.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message
   does not consume window space and can be sent even if no window space
   is available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージは, window space を消費しない. window space が残っていない場合にも送ることができる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When either party wishes to terminate the channel, it sends
   SSH_MSG_CHANNEL_CLOSE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらかの側がチャンネルを終了したいと望むなら, SSH_MSG_CHANNEL_CLOSE を送る.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Upon receiving this message, a party MUST
   send back an SSH_MSG_CHANNEL_CLOSE unless it has already sent this
   message for the channel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>まだこのメッセージを送信していないのにこのメッセージを受信した側は, SSH_MSG_CHANNEL_CLOSE を送り返さなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The channel is considered closed for a
   party when it has both sent and received SSH_MSG_CHANNEL_CLOSE, and
   the party may then reuse the channel number.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>どちらの側もSSH_MSG_CHANNEL_CLOSE を送受信したらチャンネルは終了したと見なされる. この後でチャンネル番号は再利用されるかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A party MAY send
   SSH_MSG_CHANNEL_CLOSE without having sent or received
   SSH_MSG_CHANNEL_EOF.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>SSH_MSG_CHANNEL_EOF を送信ないし受信せずに SSH_MSG_CHANNEL_CLOSE を送ってよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message does not consume window space and can be sent even if no
   window space is available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージは, window space を消費しない. window space が残っていない場合にも送ることができる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is RECOMMENDED that all data sent before this message be delivered
   to the actual destination, if possible.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>可能ならば, このメッセージの前に送られたすべてのデータが正しい送り先に伝達されることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many 'channel type' values have extensions that are specific to that
   particular 'channel type'.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多くの 'channel type' の値が, 特定の 'channel type' に特有の拡張を持つ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An example is requesting a pty (pseudo
   terminal) for an interactive session.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>例に, インタラクティブなセッションでの pty (擬似ターミナル)の要求がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, the recipient responds with either
   SSH_MSG_CHANNEL_SUCCESS, SSH_MSG_CHANNEL_FAILURE, or request-specific
   continuation messages.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 受け取り手は SSH_MSG_CHANNEL_SUCCESS ないし SSH_MSG_CHANNEL_FAILURE, もしくは 要求特有の継続メッセージを返す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request is not recognized or is not
   supported for the channel, SSH_MSG_CHANNEL_FAILURE is returned.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>要求が理解できなかったりチャンネルでサポートされていない場合は, SSH_MSG_CHANNEL_FAILURE を返す.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The values of 'request type' are local to
   each channel type.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'request type' の値は それぞれの channel type に局所的だ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client is allowed to send further messages without waiting for
   the response to the request.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントは, リクエストに対する返答を待つことなくさらなるメッセージを送ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'request type' names follow the DNS extensibility naming convention
   outlined in [SSH-ARCH] and [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'request type' の値は, [SSH-ARCH] と [SSH-NUMBERS] で説明されている DNS 拡張命名規則に従う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These messages do not consume window space and can be sent even if no
   window space is available.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらメッセージは, window space を消費しない. window space が残っていない場合にも送ることができる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program may be a
   shell, an application, a system command, or some built-in subsystem.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプログラムは, シェルやアプリケーションやシステムのコマンドや組み込まれたサブシステムだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It may or may not have a tty, and may or may not involve X11
   forwarding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプログラムは, ttyを持つかもしれないし持たないかもしれない. また, X11の転送を起動するかもしれないししないかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Client implementations SHOULD reject any session channel open
   requests to make it more difficult for a corrupt server to attack the
   client.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントの実装は, どんなセッションチャンネルの開始要求も拒否する必要がある. 邪悪なサーバがクライアントを攻撃するのをより難しくするためだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A pseudo-terminal can be allocated for the session by sending the
   following message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のメッセージを送ることで, 擬似ターミナルがセッションに割り当てられる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Zero
   dimension parameters MUST be ignored.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0 の次元パラメータは無視されなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The character/row dimensions
   override the pixel dimensions (when nonzero).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>0以外の character/row 次元パラメータは, pixel 次元を上書きする.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pixel dimensions refer
   to the drawable area of the window.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>pixel 次元は, ウィンドウの描画可能領域を参照する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X11 forwarding may be requested for a session by sending a
   SSH_MSG_CHANNEL_REQUEST message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11の転送は, セッションに SSH_MSG_CHANNEL_REQUEST メッセージを送ることで要求される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is RECOMMENDED that the 'x11 authentication cookie' that is sent
   be a fake, random cookie, and that the cookie be checked and replaced
   by the real cookie when a connection request is received.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>送られる 'x11 authentication cookie' は, にせ物のランダムなクッキーで, 接続要求が受け入れられた際にそのクッキーをチェックし置き換えることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>X11 connection forwarding should stop when the session channel is
   closed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11 接続の転送は, セッションのチャンネルが終了したら停止されるべきだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, already opened forwardings should not be
   automatically closed when the session channel is closed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, すでに開始されている転送は, セッションが終了されても自動的には終了されないべきだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If 'single connection' is TRUE, only a single connection should be
   forwarded.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'single connection' が TRUE なら, 単一の接続のみが転送されるべきだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No more connections will be forwarded after the first, or
   after the session channel has been closed.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>最初のもの以降ないしセッションチャンネルの終了以降に, 接続が転送されることはない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'x11 authentication protocol' is the name of the X11
   authentication method used, e.g., &quot;MIT-MAGIC-COOKIE-1&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'x11 authentication protocol' は, 利用するX11の認証法の名前だ. 例, &quot;MIT-MAGIC-COOKIE-1&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting
   channels are independent of the session, and closing the session
   channel does not close the forwarded X11 channels.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>開始されたチャンネルはセッションには独立で, セッションチャンネルが終了しても転送されたX11のチャンネルは終了されない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The recipient should respond with SSH_MSG_CHANNEL_OPEN_CONFIRMATION
   or SSH_MSG_CHANNEL_OPEN_FAILURE.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>受け取り手は, SSH_MSG_CHANNEL_OPEN_CONFIRMATION か SSH_MSG_CHANNEL_OPEN_FAILURE で応答しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations MUST reject any X11 channel open requests if they
   have not requested X11 forwarding.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>X11転送が要求されていない場合には, 実装はどのX11 チャンネル開始要求も拒否しなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Environment variables may be passed to the shell/command to be
   started later.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>後で開始されるシェルやコマンドに, 環境変数を転送することができる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uncontrolled setting of environment variables in a
   privileged process can be a security hazard.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>特権を持つプロセスで環境変数の設定を制御しないと, セキュリティの危険となりうる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended that
   implementations either maintain a list of allowable variable names or
   only set environment variables after the server process has dropped
   sufficient privileges.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>許可する変数名のリストを管理するかサーバプロセスが十分な権限を落したあとで環境変数を設定するかのどちらかにすることが, 実装には推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the session has been set up, a program is started at the remote
   end.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッションが設定されると, プログラムがリモート側で起動される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The program can be a shell, an application program, or a
   subsystem with a host-independent name.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このプログラムは, シェルでも, アプリケーションでも, ホストに依存しない名前を持つサブシステムでもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only one of these requests
   can succeed per channel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらの要求のうち, チャンネルごとに1つだけが成功する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message will request that the user's default shell (typically
   defined in /etc/passwd in UNIX systems) be started at the other end.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージは, もう一方の側で( UNIX システムでは典型的に /etc/passwd で定義される) ユーザのデフォルトシェルの起動を要求する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This message will request that the server start the execution of the
   given command.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージは, サーバが与えられたコマンドを実行することを要求する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Normal
   precautions MUST be taken to prevent the execution of unauthorized
   commands.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>権限のないコマンドの実行を防止する, 通常の予防措置が取られなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is expected that
   these will include a general file transfer mechanism, and possibly
   other features.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブシステムには一般的なファイル転送メカニズムやあるいは他の特徴が含まれることが期待される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations may also allow configuring more such
   mechanisms.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>実装は, このようなメカニズムをさらに設定することを許してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As the user's shell is usually used to execute the
   subsystem, it is advisable for the subsystem protocol to have a
   &quot;magic cookie&quot; at the beginning of the protocol transaction to
   distinguish it from arbitrary output generated by shell
   initialization scripts, etc.  This spurious output from the shell may
   be filtered out either at the server or at the client.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブシステムを実行するのにユーザのシェルが通常使われるので, サブシステムのプロトコルはシェルの初期化スクリプトなどで生成される任意の出力とプロトコルのトランザクションの開始時を区別するために&quot;magic cookie&quot;を持つことが望ましい. シェルからの誤った出力は, サーバないしクライアントのどちらかでフィルタされうる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The server SHOULD NOT halt the execution of the protocol stack when
   starting a shell or a program.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サーバは, シェルやプログラムの起動時にプロトコルスタックの実行を停止しないほうがよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All input and output from these
   SHOULD be redirected to the channel or to the encrypted tunnel.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シェルやプログラムからのすべての入力と出力は, チャンネルか暗号化されたトンネルにリダイレクトされる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is RECOMMENDED that the reply to these messages be requested and
   checked.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これらのメッセージに対する返答は要求され検査されることが推奨される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subsystem names follow the DNS extensibility naming convention
   outlined in [SSH-NUMBERS].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>サブシステムの名前は, [SSH-NUMBERS] で説明されている DNS 拡張命名規則に従う.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Data transfer for a session is done using SSH_MSG_CHANNEL_DATA and
   SSH_MSG_CHANNEL_EXTENDED_DATA packets and the window mechanism.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>セッションのデータ転送は, SSH_MSG_CHANNEL_DATA とSSH_MSG_CHANNEL_EXTENDED_DATA パケットと ウィンドウメカニズムを用いて行なわれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The
   extended data type SSH_EXTENDED_DATA_STDERR has been defined for
   stderr data.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>拡張データタイプ SSH_EXTENDED_DATA_STDERR が標準エラー出力のために定義されている.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the window (terminal) size changes on the client side, it MAY
   send a message to the other side to inform it of the new dimensions.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ウィンドウ (ターミナル) サイズがクライアント側で変更する場合, 新しい容量をもう一方の側に知らせるために次のメッセージを送ってもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On many systems, it is possible to determine if a pseudo-terminal is
   using control-S/control-Q flow control.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>多くのシステムで, 擬似ターミナルがControl-S/Control-Qのフロー制御を使うかどうかを決めることができる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When flow control is
   allowed, it is often desirable to do the flow control at the client
   end to speed up responses to user requests.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>フロー制御が許されているなら, ユーザのリクエストに対する応答をスピードアップするためにクライアントの側でフロー制御をすることが望ましい場合がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is facilitated by
   the following notification.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>これは次の告知によって促進される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Initially, the server is responsible for
   flow control.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>まず, サーバがフロー制御の責任を持つ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Here, again, client means the side originating the
   session, and server means the other side.)</seg>
      </tuv>
      <tuv lang="JA">
        <seg>(ここで, 繰り返すが, クライアントはセッションを始める側で, サーバはもう一方の側だ.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message below is used by the server to inform the client when it
   can or cannot perform flow control (control-S/control-Q processing).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>以下のメッセージは, サーバがクライアントにフロー制御が(Control-S/Control-Qを処理して)実行できるかどうかを知らせるのに使われる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If 'client can do' is TRUE, the client is allowed to do flow control
   using control-S and control-Q.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'client can do' が TRUEなら, クライアントは, control-S と control-Q を用いてフロー制御できる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A signal can be delivered to the remote process/service using the
   following message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>次のメッセージを用いてリモートのプロセス/サービスにシグナルが伝達される.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some systems may not implement signals, in which
   case they SHOULD ignore this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>シグナルを実装していないシステムの場合は, このメッセージは無視される必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'signal name' values will be encoded as discussed in the passage
   describing SSH_MSG_CHANNEL_REQUEST messages using &quot;exit-signal&quot; in
   this section.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'signal name' の値は, この節の &quot;exit-signal&quot; を用いる SSH_MSG_CHANNEL_REQUEST メッセージを記述している節で議論されているようにエンコードされる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the command running at the other end terminates, the following
   message can be sent to return the exit status of the command.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もう一方の側で動作していたコマンドが終了すると, コマンドの終了ステータスを返却するために次のメッセージが送られる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No acknowledgement is sent for
   this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージには応答は返らない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The channel needs to be closed with
   SSH_MSG_CHANNEL_CLOSE after this message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージの後の SSH_MSG_CHANNEL_CLOSE でチャンネルは閉じられる必要がある.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A zero
   'exit_status' usually means that the command terminated successfully.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>ゼロの 'exit_status' は, 通常コマンドが正常終了したことを意味する.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional 'signal name' values MAY be sent in the format
   &quot;sig-name@xyz&quot;, where &quot;sig-name&quot; and &quot;xyz&quot; may be anything a
   particular implementer wants (except the &quot;@&quot; sign).</seg>
      </tuv>
      <tuv lang="JA">
        <seg>追加の 'signal name' の値が, フォーマット &quot;sig-name@xyz&quot; で送られてもよい. ここで  &quot;sig-name&quot; と &quot;xyz&quot; は, (&quot;@&quot; を除く)実装者が望むどんな文字列でもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, it is
   suggested that if a 'configure' script is used, any non-standard
   'signal name' values it finds be encoded as &quot;SIG@xyz.config.guess&quot;,
   where &quot;SIG&quot; is the 'signal name' without the &quot;SIG&quot; prefix, and &quot;xyz&quot;
   is the host type, as determined by &quot;config.guess&quot;.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>しかし, 'configure' スクリプトが使われるなら, どんな非標準の 'signal name' の値も &quot;SIG@xyz.config.guess&quot; という形式でエンコードされることが推奨される. ここで, &quot;SIG&quot; は SIG接頭辞を除いた 'signal name' で &quot;xyz&quot; は &quot;config.guess&quot; で決定されるホストタイプだ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The 'error message' contains an additional textual explanation of the
   error message.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>'error message' は, 追加のエラーメッセージのテキストでの説明が含まれる.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The message may consist of multiple lines separated
   by CRLF (Carriage Return - Line Feed) pairs.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>このメッセージは,  CRLF (キャリッジリターン - ラインフィード) のペアで分割された複数行を含むかもしれない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The client software MAY
   display this message to the user.</seg>
      </tuv>
      <tuv lang="JA">
        <seg>クライアントソフトウェアは, ユーザにこのメッセージを表示してもよい.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this is done, the client
   software should take the precautions discussed in [SSH-ARCH].</seg>
      </tuv>
      <tuv lang="JA">
        <seg>もし表示するなら, クライアントソフトウェアは, [SSH-ARCH]で議論した予防措置を取らなければならない.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Ylonen &amp; Lonvick            Standards Track                     [Page 4]

RFC 4251               SSH Protocol Architecture            January 2006</seg>
      </tuv>
      <tuv lang="JA">
        <seg>.Ylonen &amp; Lonvick            Standards Track                     [Page 4]

RFC 4251               SSH Protocol Architecture            January 2006</seg>
      </tuv>
    </tu>
  </body>
</tmx>
